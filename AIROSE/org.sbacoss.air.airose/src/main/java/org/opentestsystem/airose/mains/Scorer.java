/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.mains;

import java.io.IOException;
import org.apache.log4j.Logger;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.abstractdocument.DocProcessorException;
import org.opentestsystem.airose.common.abstractdocument.DocTokenizationException;
import org.opentestsystem.airose.common.abstractdocument.TermWeightAssignmentException;
import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.common.config.ConfigurationFactory.ConfigurationType;
import org.opentestsystem.airose.db.accessors.ReadOnlyModeException;
import org.opentestsystem.airose.db.accessors.UniqueResultException;
import org.opentestsystem.airose.db.entities.MatrixLoadException;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.docquality.DocumentQualityLoader;
import org.opentestsystem.airose.docquality.processors.DocumentQualityProcessorNotImplementedException;
import org.opentestsystem.airose.linear.Matrix;
import org.opentestsystem.airose.persisters.IModelPersister;
import org.opentestsystem.airose.persisters.ModelHolder;
import org.opentestsystem.airose.regression.AbstractDocumentStats;
import org.opentestsystem.airose.regression.AbstractModel;
import org.opentestsystem.airose.regression.ModelLoadingException;
import org.opentestsystem.airose.resources.ContextBeans;
import org.opentestsystem.airose.resources.SpellCheckResource;
import org.opentestsystem.airose.sspace.InvalidReducedDimensionSpaceDataException;
import org.opentestsystem.airose.sspace.ReducedDimensionMapper;
import org.opentestsystem.airose.sspace.TermDimensionMap;
import org.opentestsystem.airose.utilities.LoggerUtil;

public class Scorer extends AbstractMain
{
  private static final Logger    LOGGER              = Logger.getLogger (Scorer.class.getName ());

  /*
   * the term-to-dimension map for this scorer.
   */
  private ReducedDimensionMapper mMapper             = null;
  /*
   * keep track of various document quality attributes.
   */
  private DocumentQualityLoader  mDocQualityAssessor = null;

  /*
   * hack!!! various resources. need to rethink the design of resources.
   */

  /*
   * the scoring model
   */
  private AbstractModel          mScoringModel       = null;

  public Scorer (String argv[]) {
    super (argv);
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#customRun()
   */
  protected void customRun () throws UninitializedException, IOException {
    // there is nothing to do here.
    // however, a separate class for performing validation may need to
    // override this one.
  }

  /*
   * Since we are going to build a model, there is no need to load anything from
   * the database. (non-Javadoc) todo: close the session if there is an
   * exception.
   * 
   * @see org.air.essayscorer.mains.AbstractMain#initialization()
   */
  protected boolean initialization () throws UninitializedException, SessionException {
    String modelId = getModelId ();
    String essayId = getEssayId ();
    String scoreType = getScoreType ();

    /*
     * load up the term index, the conversion matrices from database.
     */

    try {
      IModelPersister persister = ContextBeans.get ("IModelPersister", IModelPersister.class);
      ModelHolder mh = persister.retrieve (modelId, essayId, scoreType);

      TermDimensionMap map = mh.getDimensionMapper ();
      Matrix[] usv = mh.getUsv ();

      mMapper = new ReducedDimensionMapper (modelId, essayId, scoreType, usv, map);

      mDocQualityAssessor = mh.getDocumentQualityAttributes ();

      /*
       * load the scoring model. todo:
       */
      mScoringModel = mh.getRegressionModel ();

      // load the spell check resources as well.
      SpellCheckResource resource = (SpellCheckResource) getResources ().get (SpellCheckResource.class.getName ());
      resource.addAll (mh.getPreviouslySeenWordAccessor ());
    } catch (SessionException sqlExp) {
      sqlExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception creating session. Message: %s. Exit.", sqlExp.getMessage ());
      return false;
    } catch (UniqueResultException uniqueResultExp) {
      uniqueResultExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, uniqueResultExp.getMessage ());
      return false;
    } catch (ModelLoadingException mExp) {
      mExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, mExp.getMessage ());
      return false;
    } catch (MatrixLoadException matrixLoadExp) {
      matrixLoadExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, matrixLoadExp.getMessage ());
      return false;
    } catch (ReadOnlyModeException readOnlyExp) {
      readOnlyExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, readOnlyExp.getMessage ());
      return false;
    } catch (DocumentQualityProcessorNotImplementedException assessorNotImplementedOnlyExp) {
      assessorNotImplementedOnlyExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, assessorNotImplementedOnlyExp.getMessage ());
      return false;
    }

    return true;
  }

  protected void finish () throws UninitializedException, IOException, SessionException {
    // nothing to do here.
  }

  /*
   * Scores a document using the model that has been initialized.
   * 
   * @param doc The document object that needs to be scored.
   * 
   * @param alsoProcessAndTokenize If true then will internally invoke the
   * AbstractDocument doc object's invokeDocumentPreprocessors(),
   * invokeDocumentTokenizers and assignTermWeights() methods.
   * 
   * @return a score value.
   */
  public AbstractDocumentStats scoreResponse (AbstractDocument doc, boolean alsoProcessAndTokenize) throws DocProcessorException, DocTokenizationException, UninitializedException,
      TermWeightAssignmentException, InvalidReducedDimensionSpaceDataException {
    if (alsoProcessAndTokenize) {
      // preprocess
      doc.invokeDocumentProcessors (getResources ());
      // tokenize
      doc.invokeDocumentTokenizers ();
      // assign term weights
      doc.assignTermWeights ();
    }
    // seems like everything went fine with processing and
    // tokenization.
    // we will extract the tokens one-by-one and insert them into
    // the term-by-doc matrix.

    // a reduced document column matrix.
    Matrix docColumnVector = mMapper.getReducedDimensionVector (doc, mDocQualityAssessor);

    /*
     * fix: now the models have to handle cases where the column vectors are
     * null.
     * 
     * 
     * if (docColumnVector == null) return null;
     */
    return mScoringModel.scoreResponse (docColumnVector, doc);
  }

  /*
   * just print usage options.
   */
  protected void usage () {
    System.out.println ("usage: java " + this.getClass ().getName () + " " + mRunOptions.prettyPrint ());
  }

  protected void setupAdditionalOptions () {
    // no special options other than the default ones.
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#getConfigurationType()
   * 
   * Returns a constant value of ConfigurationType.TRAINER.
   */
  protected ConfigurationType getConfigurationType () {
    return ConfigurationType.SCORER;
  }

  protected ReducedDimensionMapper getReducedDimensionMapper () {
    return mMapper;
  }

  protected AbstractModel getScoringModel () {
    return mScoringModel;
  }

}
