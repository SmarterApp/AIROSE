/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.regression.orderedprobit;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.db.accessors.MatrixAccessor;
import org.opentestsystem.airose.db.accessors.ModelEntryAccessor;
import org.opentestsystem.airose.db.entities.EnumScoringStatus;
import org.opentestsystem.airose.db.entities.Model;
import org.opentestsystem.airose.db.entities.ModelEntriesType;
import org.opentestsystem.airose.db.entities.ModelEntry;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.linear.*;
import org.opentestsystem.airose.regression.AbstractDocumentStats;
import org.opentestsystem.airose.regression.AbstractModel;
import org.opentestsystem.airose.regression.ModelLoadingException;
import org.opentestsystem.airose.utilities.StringUtils;

public class OrderedProbitModel extends AbstractModel
{
  private Integer[]     mCategories;
  private double[]      mCategoryCuts;
  private double        mConstantCoefficient;
  private double[]      mCoefficients;
  private OrderedProbit mOrderedProbit = null;

  public OrderedProbitModel () {
    super ();
  }

  public OrderedProbitModel (Integer[] categories, double[] categoryCuts, double constantCoefficient, double[] coefficients, double[] yVector, double[][] xVector) {
    super (yVector, xVector);
    this.mCategories = categories;
    this.mCategoryCuts = categoryCuts;
    this.mConstantCoefficient = constantCoefficient;
    this.mCoefficients = coefficients;
  }

  public void saveToDatabaseCustom (ModelEntryAccessor dbModelAccessor, MatrixAccessor dbMatrixAccessor, Model md, String outputFolder) throws SessionException, FileNotFoundException {

    PrintWriter prn = new PrintWriter (outputFolder + "/OrderedProbitModel.csv");

    // write the header.
    final String CSV_STRING = "{0}, {1}, {2}";
    prn.println (StringUtils.format (CSV_STRING, "Entry", "Index", "Type"));

    ArrayList<ModelEntry> listOfEntries = new ArrayList<ModelEntry> ();
    for (int counter1 = 0; counter1 < mCategories.length; ++counter1) {
      ModelEntry me = new ModelEntry (md.getId (), mCategories[counter1], counter1, ModelEntriesType.CATEGORIES);

      prn.println (StringUtils.format (CSV_STRING, "" + mCategories[counter1], "" + counter1, ModelEntriesType.CATEGORIES.toString ()));
      listOfEntries.add (me);
    }

    listOfEntries.add (new ModelEntry (md.getId (), mConstantCoefficient, 0, ModelEntriesType.CONSTANT_COEFFICIENT));
    prn.println (StringUtils.format (CSV_STRING, "" + mConstantCoefficient, "0", ModelEntriesType.CONSTANT_COEFFICIENT.toString ()));

    // save residuals.
    for (int counter1 = 0; counter1 < this.mCategoryCuts.length; ++counter1) {
      ModelEntry me = new ModelEntry (md.getId (), this.mCategoryCuts[counter1], counter1, ModelEntriesType.CATEGORY_CUTS);
      prn.println (StringUtils.format (CSV_STRING, "" + this.mCategoryCuts[counter1], "" + counter1, ModelEntriesType.CATEGORY_CUTS.toString ()));
      listOfEntries.add (me);
    }

    // save parameters variance.
    for (int counter1 = 0; counter1 < this.mCoefficients.length; ++counter1) {
      ModelEntry me = new ModelEntry (md.getId (), this.mCoefficients[counter1], counter1, ModelEntriesType.COEFFICENTS);
      prn.println (StringUtils.format (CSV_STRING, "" + this.mCoefficients[counter1], "" + counter1, ModelEntriesType.COEFFICENTS.toString ()));

      listOfEntries.add (me);
    }

    dbModelAccessor.saveModelEntries (listOfEntries.iterator ());
    prn.close ();
  }

  public void loadFromDatabase (Model md, ModelEntryAccessor dbAccessor, int totalRegressorsUsed) throws SessionException, ModelLoadingException {

    // step 1: Load coefficients.
    List<ModelEntry> coefficientEntries = dbAccessor.getModelEntries (md, ModelEntriesType.COEFFICENTS);
    if (coefficientEntries == null || coefficientEntries.size () == 0)
      throw new ModelLoadingException (String.format ("No coefficients could be retrieved for modeid %s, essay id %s, score type %s", md.getModelId (), md.getEssayId (), md.getScoreType ()));
    // make sure there are as many coefficients as regressors.
    if (coefficientEntries.size () != totalRegressorsUsed)
      throw new ModelLoadingException (String.format ("%d coefficients retrieved for modeid %s, essay id %s, score type %s does not meet the expected size of %d", coefficientEntries.size (),
          md.getModelId (), md.getEssayId (), md.getScoreType (), md.getNumberOfDimensions () + 1));

    mCoefficients = new double[totalRegressorsUsed];
    for (ModelEntry me : coefficientEntries) {
      mCoefficients[me.getIndex ()] = me.getEntry ();
    }

    // step 2: Load categories.
    List<ModelEntry> categoriesEntries = dbAccessor.getModelEntries (md, ModelEntriesType.CATEGORIES);
    if (categoriesEntries == null || categoriesEntries.size () == 0)
      throw new ModelLoadingException (String.format ("No categories could be retrieved for modeid %s, essay id %s, score type %s", md.getModelId (), md.getEssayId (), md.getScoreType ()));

    // todo: check that the count of retrieved numbers is as expected.
    mCategories = new Integer[categoriesEntries.size ()];
    for (ModelEntry me : categoriesEntries) {
      mCategories[me.getIndex ()] = (int) me.getEntry ();
    }

    // step 3: Load categoryCuts.
    List<ModelEntry> categoriesCutsEntries = dbAccessor.getModelEntries (md, ModelEntriesType.CATEGORY_CUTS);
    // if there are only two categories then we wont have category cuts.
    // todo: this logic should be moved to OrderedProbit but I wanted to leave
    // Paul's code intact and that is why this is here.
    if ((categoriesCutsEntries == null || categoriesCutsEntries.size () == 0) && (mCategories.length > 2))
      throw new ModelLoadingException (String.format ("No categoryCuts could be retrieved for modeid %s, essay id %s, score type %s", md.getModelId (), md.getEssayId (), md.getScoreType ()));
    // todo: check that the count of retrieved numbers is as expected.
    if (categoriesCutsEntries != null && categoriesCutsEntries.size () > 0) {
      mCategoryCuts = new double[categoriesCutsEntries.size ()];
      for (ModelEntry me : categoriesCutsEntries) {
        mCategoryCuts[me.getIndex ()] = me.getEntry ();
      }
    }

    // step 4: load constant coefficient.
    List<ModelEntry> constantCoefficientEntries = dbAccessor.getModelEntries (md, ModelEntriesType.CONSTANT_COEFFICIENT);
    if (constantCoefficientEntries == null || constantCoefficientEntries.size () != 1)
      throw new ModelLoadingException (String.format ("No categoryCuts could be retrieved for modeid %s, essay id %s, score type %s", md.getModelId (), md.getEssayId (), md.getScoreType ()));
    this.mConstantCoefficient = constantCoefficientEntries.get (0).getEntry ();
    mOrderedProbit = new OrderedProbit (mCategories, mCategoryCuts, mConstantCoefficient, mCoefficients);
  }

  public AbstractDocumentStats scoreResponse (Matrix docColumnMatrix, AbstractDocument ownerDoc) {

    OrderedProbitDocumentStats docStats = new OrderedProbitDocumentStats (ownerDoc);

    if (docColumnMatrix != null) {
      double[] independentValues = new double[docColumnMatrix.rows ()];

      for (int counter1 = 0; counter1 < docColumnMatrix.rows (); ++counter1) {
        independentValues[counter1] = docColumnMatrix.get (counter1, 0);
      }

      int scoreCategory = mOrderedProbit.Predict (independentValues, docStats);

      docStats.setNewScore (scoreCategory);
      docStats.setScoringMessage (EnumScoringStatus.SUCCESS);
    } else {
      // !!! hacky.
      for (int counter1 = 0; counter1 < mOrderedProbit.getCategories ().length; ++counter1) {
        docStats.addToCategoryProbabilities (0);
      }

      docStats.setNewScore (0);
      docStats.setScoringMessage (EnumScoringStatus.NOT_ENOUGH_DATA);
    }
    return docStats;
  }

  @SuppressWarnings ("rawtypes")
  public List createEmptyDocumentStatsLists () {
    return new ArrayList<OrderedProbitDocumentStats> ();
  }
}
