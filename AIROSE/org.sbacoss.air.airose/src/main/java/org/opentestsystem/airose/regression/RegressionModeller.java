/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.regression;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.log4j.Logger;
import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.abstractdocument.AbstractResource;
import org.opentestsystem.airose.common.config.ConfigurationFactory;
import org.opentestsystem.airose.common.config.TrainerConfiguration;
import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.docquality.DocumentQualityLoader;
import org.opentestsystem.airose.document.DocumentFactory;
import org.opentestsystem.airose.linear.Matrix;
import org.opentestsystem.airose.sspace.ReducedDimensionMapper;
import org.opentestsystem.airose.utilities.LoggerUtil;

public class RegressionModeller
{

  private HashMap<String, AbstractResource> mResourcesMap            = null;

  private static final Logger               LOGGER                   = Logger.getLogger (RegressionModeller.class.getName ());
  /**
   * The counter for recording the current number of documents observed.
   * Subclasses can use this for any reporting.
   */
  protected AtomicInteger                   mDocumentCounter         = new AtomicInteger (0);
  /*
   * the three tuple value to uniquely identify a model.
   */
  private String                            mModelId                 = null;
  private String                            mEssayId                 = null;
  private String                            mScoreType               = null;
  private String                            mOutputFolder            = null;

  /*
   * worker object to reduce the document vector to the reduced dimension.
   */
  private ReducedDimensionMapper            mMapper                  = null;
  /*
   * worker object to assign document quality weights.
   */
  private DocumentQualityLoader             mDocumentQualityAssessor = null;

  public RegressionModeller (String modelId, String essayId, String scoreType, ReducedDimensionMapper mapper, DocumentQualityLoader documentQualityAssessor,
      HashMap<String, AbstractResource> resources, String outputFolder) {
    mModelId = modelId;
    mEssayId = essayId;
    mScoreType = scoreType;
    mMapper = mapper;
    mDocumentQualityAssessor = documentQualityAssessor;
    mResourcesMap = resources;
    mOutputFolder = outputFolder;
  }

  /*
	 * 
	 */
  public AbstractModel runRegressionModelling (String directoryPath) throws UninitializedException, RegressionModellingException {

    List<Double> yVectorList = new ArrayList<Double> ();
    List<Double[]> xVectorList = new ArrayList<Double[]> ();
    List<String> docVectorList = new ArrayList<String> ();

    File directory = new File (directoryPath);
    String[] listOfFiles = directory.list ();
    for (String file : listOfFiles) {
      BufferedReader reader = null;
      try {
        String fileName = directoryPath + "/" + file;
        reader = new BufferedReader (new FileReader (fileName));
        processDocument (fileName, reader, yVectorList, xVectorList, docVectorList);
      } catch (IOException exp) {
        exp.printStackTrace ();
        LoggerUtil.severe (LOGGER, "Exception processing files for regression modelling. Message: %s", exp.getMessage ());
      } finally {
        try {
          reader.close ();
        } catch (NullPointerException exp) {
          // do nothing.
        } catch (IOException exp) {
          // do nothing.
        }
      }
    }

    // todo: use toArray instead. this is really inefficient.
    double[] yVectorArray = new double[yVectorList.size ()];
    for (int counter1 = 0; counter1 < yVectorArray.length; ++counter1)
      yVectorArray[counter1] = yVectorList.get (counter1);

    double[][] xVectorArray = new double[xVectorList.size ()][];
    for (int counter1 = 0; counter1 < yVectorArray.length; ++counter1) {
      xVectorArray[counter1] = new double[xVectorList.get (counter1).length];
      for (int counter2 = 0; counter2 < xVectorList.get (counter1).length; ++counter2) {
        xVectorArray[counter1][counter2] = xVectorList.get (counter1)[counter2];
      }
    }
    // save the regression matrix to a file.
    printInputMatrix (yVectorArray, xVectorArray, docVectorList);
    // now start modelling.
    TrainerConfiguration runConfig = (TrainerConfiguration) ConfigurationFactory.getConfiguration ();
    AbstractRegressionAlgorithm algorithmToUse = RegressionAlgorithmFactory.getRegressionAlgorithm (runConfig.getRegressionModel ());
    return algorithmToUse.generateModel (yVectorArray, xVectorArray);
  }

  private void processDocument (String fileName, BufferedReader document, List<Double> yVectorList, List<Double[]> xVectorList, List<String> docVectorList) {
    String line = null;
    try {
      while ((line = document.readLine ()) != null) {
        try {
          // Each line consists of a score and a response separated by
          // a
          // comma. First process and tokenize the document.
          AbstractDocument doc = DocumentFactory.getDocument (fileName, line, mEssayId, -1);
          // process
          doc.invokeDocumentProcessors (mResourcesMap);
          // tokenize
          doc.invokeDocumentTokenizers ();
          // assign term weights
          doc.assignTermWeights ();

          // seems like everything went fine with processing and
          // tokenization.
          // we will extract the tokens one-by-one and insert them
          // into
          // the term-by-doc matrix.
          Matrix reducedDimensionColumnMatrix = mMapper.getReducedDimensionVector (doc, mDocumentQualityAssessor);

          if (reducedDimensionColumnMatrix != null) {
            Double[] xVectorTemp = new Double[reducedDimensionColumnMatrix.rows ()];
            for (int counter2 = 0; counter2 < reducedDimensionColumnMatrix.rows (); ++counter2) {
              xVectorTemp[counter2] = reducedDimensionColumnMatrix.get (counter2, 0);
            }

            yVectorList.add (doc.getScore ());
            xVectorList.add (xVectorTemp);
            docVectorList.add (doc.getDocId ());
            // Increases the count of documents observed so far.
            mDocumentCounter.getAndAdd (1);
          }
        } catch (Exception exp) {
          LoggerUtil.severe (LOGGER, "Exception invoking docProcessors/docTokenizers on \"%s\". Message: %s", line, exp.getMessage ());
        }
      }

      // close the document.
      document.close ();
    } catch (IOException exp) {
      // do nothing.
    }
  }

  // todo: design this better.
  private void printInputMatrix (double[] yVector, double[][] xVector, List<String> docVectorList) {
    try {
      String outputFile = mOutputFolder + "/regressionMatrix.csv";
      PrintStream prn = new PrintStream (new FileOutputStream (outputFile));
      // print header.
      prn.print ("docId<string>, y");
      for (int counter1 = 0; counter1 < xVector[0].length; ++counter1)
        prn.print (String.format (", x[%d]", counter1));
      prn.println ("");

      for (int counter1 = 0; counter1 < yVector.length; ++counter1) {
        prn.print (docVectorList.get (counter1) + "," + yVector[counter1]);
        for (int counter2 = 0; counter2 < xVector[counter1].length; ++counter2) {
          prn.print ("," + xVector[counter1][counter2]);
        }
        prn.println ("");
      }

      prn.close ();
    } catch (Exception exp) {

    }
  }

}
