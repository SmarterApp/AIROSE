/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.regression.orderedprobit;

// /////////////////////////////////////////////////////////////////////
// FileName: NormalDistribution.cs
// Desc:
// Date Created: 1/6/2011 Created By: Paul Van Wamelen
// Major Revision History:
// Ported to Java by SBehera
// /////////////////////////////////////////////////////////////////////

public class NormalDistribution
{
  private final static double SQRTH  = 7.07106781186547524401E-1;
  private final static double MAXLOG = 7.09782712893383996732E2;

  public static double PDF (double x) {
    double sqrt2PI = 2.506628274631001;
    return Math.exp (-x * x / 2) / sqrt2PI;
  }

  // Adapted from AM's version of CDF
  // Only good to about 6 decimal places!
  static public double CDF_AM (double z) {
    double t = 1.0 / (1.0 + .33267 * Math.abs (z));

    if (z > 0)
      return 1.0 - PDF (z) * (.4361836 + (-.1201676 + .9372980 * t) * t) * t;
    else
      return PDF (z) * (.4361836 + (-.1201676 + .9372980 * t) * t) * t;
  }

  // Adapted from http://www.johndcook.com/csharp_erf.html
  // Only good to about 8 decimal places!
  static public double CDF0 (double x) {
    // constants
    double a1 = 0.254829592;
    double a2 = -0.284496736;
    double a3 = 1.421413741;
    double a4 = -1.453152027;
    double a5 = 1.061405429;
    double p = 0.3275911;
    double sqrt2 = 1.414213562373095;

    // Save the sign of x
    x = x / sqrt2;
    int sign = 1;
    if (x < 0) {
      sign = -1;
      x = -x;
    }

    // A&S formula 7.1.26
    double t = 1.0 / (1.0 + p * x);
    if (sign == -1)
      return 0.5 * (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp (-x * x);
    else
      return 1.0 - 0.5 * (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp (-x * x);
  }

  // / <summary>
  // / Returns the area under the Gaussian probability density function,
  // integrated from minus infinity to a.
  // /
  // / Seems to be good to essentially 16 decimal places.
  // / From http://www.codeproject.com/KB/cs/SpecialFunction.aspx
  // / </summary>
  // / <param name="a"></param>
  // / <returns></returns>

  public static double CDF (double a) {
    double x, y, z;

    x = a * SQRTH;
    z = Math.abs (x);

    if (z < SQRTH)
      y = 0.5 + 0.5 * erf (x);
    else {
      y = 0.5 * erfc (z);
      if (x > 0)
        y = 1.0 - y;
    }

    return y;
  }

  // / <summary>
  // / Returns the complementary error function of the specified number.
  // / </summary>
  // / <param name="a"></param>
  // / <returns></returns>
  private static double erfc (double a) {
    double x, y, z, p, q;

    double[] P = { 2.46196981473530512524E-10, 5.64189564831068821977E-1, 7.46321056442269912687E0, 4.86371970985681366614E1, 1.96520832956077098242E2, 5.26445194995477358631E2,
        9.34528527171957607540E2, 1.02755188689515710272E3, 5.57535335369399327526E2 };
    double[] Q = {
        // 1.0
        1.32281951154744992508E1, 8.67072140885989742329E1, 3.54937778887819891062E2, 9.75708501743205489753E2, 1.82390916687909736289E3, 2.24633760818710981792E3, 1.65666309194161350182E3,
        5.57535340817727675546E2 };

    double[] R = { 5.64189583547755073984E-1, 1.27536670759978104416E0, 5.01905042251180477414E0, 6.16021097993053585195E0, 7.40974269950448939160E0, 2.97886665372100240670E0 };
    double[] S = {
        // 1.00000000000000000000E0,
        2.26052863220117276590E0, 9.39603524938001434673E0, 1.20489539808096656605E1, 1.70814450747565897222E1, 9.60896809063285878198E0, 3.36907645100081516050E0 };

    if (a < 0.0)
      x = -a;
    else
      x = a;

    if (x < 1.0)
      return 1.0 - erf (a);

    z = -a * a;

    if (z < -MAXLOG) {
      if (a < 0)
        return (2.0);
      else
        return (0.0);
    }

    z = Math.exp (z);

    if (x < 8.0) {
      p = polevl (x, P, 8);
      q = p1evl (x, Q, 8);
    } else {
      p = polevl (x, R, 5);
      q = p1evl (x, S, 6);
    }

    y = (z * p) / q;

    if (a < 0)
      y = 2.0 - y;

    if (y == 0.0) {
      if (a < 0)
        return 2.0;
      else
        return (0.0);
    }

    return y;
  }

  // / <summary>
  // / Returns the error function of the specified number.
  // / </summary>
  // / <param name="x"></param>
  // / <returns></returns>
  public static double erf (double x) {
    double y, z;
    double[] T = { 9.60497373987051638749E0, 9.00260197203842689217E1, 2.23200534594684319226E3, 7.00332514112805075473E3, 5.55923013010394962768E4 };
    double[] U = {
        // 1.00000000000000000000E0,
        3.35617141647503099647E1, 5.21357949780152679795E2, 4.59432382970980127987E3, 2.26290000613890934246E4, 4.92673942608635921086E4 };

    if (Math.abs (x) > 1.0)
      return (1.0 - erfc (x));
    z = x * x;
    y = x * polevl (z, T, 4) / p1evl (z, U, 5);
    return y;
  }

  // / <summary>
  // / Evaluates polynomial of degree N
  // / </summary>
  // / <param name="x"></param>
  // / <param name="coef"></param>
  // / <param name="N"></param>
  // / <returns></returns>
  private static double polevl (double x, double[] coef, int N) {
    double ans;

    ans = coef[0];

    for (int i = 1; i <= N; i++) {
      ans = ans * x + coef[i];
    }

    return ans;
  }

  // / <summary>
  // / Evaluates polynomial of degree N with assumtion that coef[N] = 1.0
  // / </summary>
  // / <param name="x"></param>
  // / <param name="coef"></param>
  // / <param name="N"></param>
  // / <returns></returns>
  private static double p1evl (double x, double[] coef, int N) {
    double ans;

    ans = x + coef[0];

    for (int i = 1; i < N; i++) {
      ans = ans * x + coef[i];
    }

    return ans;
  }

  /*
   * /// <summary> /// Quantile function (Inverse CDF) for the normal
   * distribution. /// </summary> /// <param name="p">Probability.</param> ///
   * <param name="mu">Mean of normal distribution.</param> /// <param
   * name="sigma">Standard deviation of normal distribution.</param> /// <param
   * name="lower_tail">If true, probability is P[X <= x], otherwise P[X >
   * x].</param> /// <param name="log_p">If true, probabilities are given as
   * log(p).</param> /// <returns>P[X <= x] where x ~ N(mu,sigma^2)</returns>
   * /// <remarks>See
   * https://svn.r-project.org/R/trunk/src/nmath/qnorm.c</remarks> public static
   * double QNorm(double p, double mu, double sigma, bool lower_tail, bool
   * log_p) { if (double.IsNaN(p) || double.IsNaN(mu) || double.IsNaN(sigma))
   * return (p + mu + sigma); double ans; bool isBoundaryCase =
   * R_Q_P01_boundaries(p, double.NegativeInfinity, double.PositiveInfinity,
   * lower_tail, log_p, out ans); if (isBoundaryCase) return (ans); if (sigma <
   * 0) return (double.NaN); if (sigma == 0) return (mu);
   * 
   * double p_ = R_DT_qIv(p, lower_tail, log_p); double q = p_ - 0.5; double r,
   * val;
   * 
   * if (Math.Abs(q) <= 0.425) // 0.075 <= p <= 0.925 { r = .180625 - q * q; val
   * = q * (((((((r * 2509.0809287301226727 + 33430.575583588128105) * r +
   * 67265.770927008700853) * r + 45921.953931549871457) * r +
   * 13731.693765509461125) * r + 1971.5909503065514427) * r +
   * 133.14166789178437745) * r + 3.387132872796366608) / (((((((r *
   * 5226.495278852854561 + 28729.085735721942674) * r + 39307.89580009271061) *
   * r + 21213.794301586595867) * r + 5394.1960214247511077) * r +
   * 687.1870074920579083) * r + 42.313330701600911252) * r + 1.0); } else { r =
   * q > 0 ? R_DT_CIv(p, lower_tail, log_p) : p_; r = Math.Sqrt(-((log_p &&
   * ((lower_tail && q <= 0) || (!lower_tail && q > 0))) ? p : Math.Log(r)));
   * 
   * if (r <= 5) // <==> min(p,1-p) >= exp(-25) ~= 1.3888e-11 { r -= 1.6; val =
   * (((((((r * 7.7454501427834140764e-4 + .0227238449892691845833) * r +
   * .24178072517745061177) * r + 1.27045825245236838258) * r +
   * 3.64784832476320460504) * r + 5.7694972214606914055) * r +
   * 4.6303378461565452959) * r + 1.42343711074968357734) / (((((((r *
   * 1.05075007164441684324e-9 + 5.475938084995344946e-4) * r +
   * .0151986665636164571966) * r + .14810397642748007459) * r +
   * .68976733498510000455) * r + 1.6763848301838038494) * r +
   * 2.05319162663775882187) * r + 1.0); } else // very close to 0 or 1 { r -=
   * 5.0; val = (((((((r * 2.01033439929228813265e-7 +
   * 2.71155556874348757815e-5) * r + .0012426609473880784386) * r +
   * .026532189526576123093) * r + .29656057182850489123) * r +
   * 1.7848265399172913358) * r + 5.4637849111641143699) * r +
   * 6.6579046435011037772) / (((((((r * 2.04426310338993978564e-15 +
   * 1.4215117583164458887e-7) * r + 1.8463183175100546818e-5) * r +
   * 7.868691311456132591e-4) * r + .0148753612908506148525) r +
   * .13692988092273580531) * r + .59983220655588793769) * r + 1.0); } if (q <
   * 0.0) val = -val; }
   * 
   * return (mu + sigma * val); }
   */

  // from AM, but probably originally from
  // http://home.online.no/~pjacklam/notes/invnorm/
  public static double InverseCDF (double p) throws OrderedProbitException {
    double a0 = -3.969683028665376E1;
    double a1 = 2.209460984245205E2;
    double a2 = -2.759285104469687E2;
    double a3 = 1.383577518672690E2;
    double a4 = -3.066479806614716E1;
    double a5 = 2.506628277459239;
    double b0 = -5.447609879822406E1;
    double b1 = 1.615858368580409E2;
    double b2 = -1.556989798598866E2;
    double b3 = 6.680131188771972E1;
    double b4 = -1.328068155288572E1;
    double c0 = -7.784894002430293E-3;
    double c1 = -3.223964580411365E-1;
    double c2 = -2.400758277161838;
    double c3 = -2.549732539343734;
    double c4 = 4.374664141464968;
    double c5 = 2.938163982698783;
    double d0 = 7.784695709041462E-3;
    double d1 = 3.224671290700398E-1;
    double d2 = 2.445134137142996;
    double d3 = 3.754408661907416;

    double q, t, u;

    if (Double.isNaN (p) || p > 1.0 || p < 0.0)
      throw new OrderedProbitException ("Argument to NormalDistribution.InverseCDF must be a number between 0 and 1, not " + p);

    if (p == 0.0)
      return Double.NEGATIVE_INFINITY;
    if (p == 1.0)
      return Double.POSITIVE_INFINITY;

    q = Math.min (p, 1 - p);

    if (q > 0.02425) {
      /* Rational approximation for central region. */
      u = q - 0.5;
      t = u * u;
      u = u * (((((a0 * t + a1) * t + a2) * t + a3) * t + a4) * t + a5) / (((((b0 * t + b1) * t + b2) * t + b3) * t + b4) * t + 1);
    } else {
      /* Rational approximation for tail region. */
      t = Math.sqrt (-2 * Math.log (q));
      u = (((((c0 * t + c1) * t + c2) * t + c3) * t + c4) * t + c5) / ((((d0 * t + d1) * t + d2) * t + d3) * t + 1);
    }
    /*
     * The relative error of the approximation has absolute value less than
     * 1.15e-9. One iteration of Halley's rational method (third order) gives
     * full machine precision...
     */
    // t = stdnormal_cdf(u)-q; /* error */
    // t = t*M_SQRT2PI*exp(u*u/2); /* f(u)/df(u) */
    // u = u-t/(1+u*t/2); /* Halley's method */

    return (p > 0.5 ? -u : u);
  }

  // From http://www.johndcook.com/normal_cdf_inverse.html combined with
  // Halley's method
  // Doesn't quite work, probably because CDF is bad...
  static public double InverseCDF2 (double p) throws OrderedProbitException {
    if (Double.isNaN (p) || p > 1.0 || p < 0.0)
      throw new OrderedProbitException ("Argument to NormalDistribution.InverseCDF must be a number between 0 and 1, not " + p);

    if (p == 0.0)
      return Double.NEGATIVE_INFINITY;
    if (p == 1.0)
      return Double.POSITIVE_INFINITY;

    int sign = 1;
    double t;
    double q;
    if (p < 0.5) {
      sign = -1;
      q = p;
    } else {
      q = 1 - p;
    }
    t = Math.sqrt (-2 * Math.log (q));

    // Abramowitz and Stegun formula 26.2.23.
    // The absolute value of the error should be less than 4.5 e-4.
    double sqrt2PI = 2.506628274631001;
    double c0 = 2.515517;
    double c1 = 0.802853;
    double c2 = 0.010328;
    double d0 = 1.432788;
    double d1 = 0.189269;
    double d2 = 0.001308;

    double u = sign * (t - ((c2 * t + c1) * t + c0) / (((d2 * t + d1) * t + d0) * t + 1.0));

    t = CDF (u) - q; /* error */
    t = t * sqrt2PI * Math.exp (u * u / 2); /* f(u)/df(u) */
    u = u - t / (1 + u * t / 2); /* Halley's method */

    return u;
  }
}
