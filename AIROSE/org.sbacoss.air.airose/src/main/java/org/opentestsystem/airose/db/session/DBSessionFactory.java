/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.db.session;

import java.sql.SQLException;
import org.apache.log4j.Logger;

import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.utilities.LoggerUtil;

/*
 * This class manages / configures hibernate sessions.
 */
public class DBSessionFactory
{
  private static final Logger           LOGGER           = Logger.getLogger (DBSessionFactory.class.getName ());
  /*
   * a thread local storage for the currently open session and transaction.
   */
  private static ThreadLocal<DBSession> myCurrentSession = null;

  private static DBSessionFactory       singleton        = null;

  /*
   * return an instance of the DBSessionFactory. This is pretty much the first
   * call that should be made before any database action is performed. the
   * subsequent actions may be openSession(), beginTransaction(),
   * commitTransaction() and closeSession() and last of all
   * shutdownDBConnection().
   */
  public static DBSessionFactory getInstance () {
    if (singleton != null)
      return singleton;
    try {
      init ();
    } catch (UninitializedException exp) {
      LoggerUtil.severe (LOGGER, "Could not create session %s.", exp.getMessage ());
      return null;
    }
    return singleton;
  }

  /*
   * implicitly creates a thread specific hibernate session. todo: threadlocal
   * may be an expensive operation so this may need to be looked into later.
   */
  public DBSession getSession (int creatorHashcode) throws UninitializedException {
    if (myCurrentSession == null || (myCurrentSession.get () == null) || (!myCurrentSession.get ().isSessionOpen ())) {
      myCurrentSession = new ThreadLocal<DBSession> ();
      myCurrentSession.set (new DBSession (creatorHashcode, DBSetUp.getInstance ().createSession ()));
    }
    return myCurrentSession.get ();
  }

  /*
   * shutdown the database. this is only required in the case of some databases
   * e.g. embedded databases. this method should always be called.
   */
  public void shutdownDBConnection () {
    try {
      DBSetUp.getInstance ().shutdown ();
    } catch (UninitializedException exp) {
      LoggerUtil.severe (LOGGER, "Could not create session. Something is wrong with configuration. Exception: %s", exp.getMessage ());
    } catch (SQLException exp) {
      LoggerUtil.severe (LOGGER, "Could not create session. Exception: %s.", exp.getMessage ());
    }
  }

  private DBSessionFactory () {
  }

  private static synchronized void init () throws UninitializedException {
    DBSetUp.getInstance ();
    singleton = new DBSessionFactory ();
  }
}
