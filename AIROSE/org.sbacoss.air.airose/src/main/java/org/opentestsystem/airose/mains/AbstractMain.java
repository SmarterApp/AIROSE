/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.mains;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;

import org.apache.log4j.Logger;
import org.apache.log4j.xml.DOMConfigurator;
import org.opentestsystem.airose.common.abstractdocument.AbstractResource;
import org.opentestsystem.airose.common.config.ConfigurationFactory;
import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.common.config.ConfigurationFactory.ConfigurationType;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.optionCli.ArgOptions;
import org.opentestsystem.airose.resources.SpellCheckResource;
import org.opentestsystem.airose.sspace.LSANotInitializedException;
import org.opentestsystem.airose.utilities.LoggerUtil;

public abstract class AbstractMain extends Thread
{

  private HashMap<String, AbstractResource> mResources  = new HashMap<String, AbstractResource> ();

  private static final Logger               LOGGER      = Logger.getLogger (AbstractMain.class.getName ());
  /*
   * parse argument options.
   */
  protected ArgOptions                      mRunOptions = null;

  /*
   * command line argument options passed as is.
   */
  protected String                          mArgv[]     = null;

  public AbstractMain (String argv[]) {
    this.mArgv = argv;
  }

  public void run () {
    if (mArgv.length == 0) {
      usage ();
      System.exit (1);
    }
    setupAllOptions ();
    this.mRunOptions.parseOptions (mArgv);
    try {
      setUpConfiguration ();
    } catch (IOException exp) {
      exp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception setting up configuration. Message: %s", exp.getMessage ());
    }
    setUpLogLevel ();
    // register resources.
    registerResources ();
    try {
      if (!initialization ())
        return;
      customRun ();
      finish ();
    } catch (UninitializedException exp) {
      LoggerUtil.severe (LOGGER, "Exception getting configuration parameters. Message: %s", exp.getMessage ());
    } catch (IOException ioExp) {
      LoggerUtil.severe (LOGGER, "Exception saving data. Message: %s", ioExp.getMessage ());
    } catch (SessionException sExp) {
      LoggerUtil.severe (LOGGER, "Exception with hibernate session. Message: %s", sExp.getMessage ());
    } catch (LSANotInitializedException sExp) {
      LoggerUtil.severe (LOGGER, "Exception with LSA processing. Message: %s", sExp.getMessage ());
    }

  }

  public void setUpConfiguration () throws IOException {

    String configurationFileName = null;
    if (mRunOptions.hasOption ('c'))
      configurationFileName = mRunOptions.getStringOption ('c');
    else if (mRunOptions.hasOption ("configFile"))
      configurationFileName = mRunOptions.getStringOption ("configFile");
    else {
      usage ();
      System.exit (0);
    }

    ConfigurationFactory.initializeConfiguration (configurationFileName, getConfigurationType ());
  }

  /*
   * Needs to return one of the values in the enum ConfigurationType.
   * 
   * @return ConfigurationType enum value.
   */
  protected abstract ConfigurationType getConfigurationType ();

  protected abstract void setupAdditionalOptions ();

  /*
   * should just print how to run this program.
   * 
   * @return nothing.
   */
  protected abstract void usage ();

  /*
   * will execute task (e.g. Trainer, Validation or Scorer specific tasks)
   * 
   * @return nothing.
   */
  protected abstract void customRun () throws UninitializedException, IOException, LSANotInitializedException;

  protected abstract void finish () throws UninitializedException, IOException, SessionException;

  /*
   * if any initial data needs to be loaded up...
   */
  protected abstract boolean initialization () throws UninitializedException, SessionException;

  /*
   * will create the folder if it does not exist. this method however, does not
   * check if the existing folder path is indeed a folder or just a regular
   * file.
   */
  protected void createFolder (String folderPath) {
    File f = new File (folderPath);
    if (f.isDirectory ())
      return;
    f.mkdirs ();
  }

  /*
   * gets the score type. this is required in case the essay has scores along
   * multiple dimensions.
   */
  protected String getScoreType () {
    if (mRunOptions.hasOption ('t'))
      return mRunOptions.getStringOption ('t');
    else if (mRunOptions.hasOption ("scoreType"))
      return mRunOptions.getStringOption ("scoreType");
    else {
      return "default";
    }
  }

  /*
   * get the model id as passed in. this groups a bunch of models for different
   * essays into one identifiable set.
   */
  protected String getModelId () {
    if (mRunOptions.hasOption ('m'))
      return mRunOptions.getStringOption ('m');
    else if (mRunOptions.hasOption ("modelId"))
      return mRunOptions.getStringOption ("modelId");
    else {
      usage ();
      System.exit (0);
      return null;
    }
  }

  /*
   * a unique essay id for this run. we need to identify output in database.
   * this has to be unique.
   */
  protected String getEssayId () {
    if (mRunOptions.hasOption ('i'))
      return mRunOptions.getStringOption ('i');
    else if (mRunOptions.hasOption ("essayId"))
      return mRunOptions.getStringOption ("essayId");
    else {
      usage ();
      System.exit (0);
      return null;
    }
  }

  protected void addInputFolderOption () {
    // Add input folder.
    mRunOptions.addOption ('d', "inputDirectory",
        "a folder with (possibly) multiple files in which each line is a score and a response separated by a comma. the file does not need to confirm to CVS format.", true, "Folder", "Required");
  }

  protected void addOutputFolderOption () {

    // Add option for output folder. the semantic space file will
    // saved to this folder along with other possible files.
    mRunOptions.addOption ('o', "outputDirectory", "a folder to which output files will be written.", true, "OutputFolder", "Required");
  }

  protected String getInputFolderName () {
    if (mRunOptions.hasOption ('d'))
      return mRunOptions.getStringOption ('d');
    else if (mRunOptions.hasOption ("inputDirectory"))
      return mRunOptions.getStringOption ("inputDirectory");
    else {
      usage ();
      System.exit (0);
      return null;
    }
  }

  /*
   * the output folder as given in the command line.
   */
  protected String getOutputFolder () {
    String optionValue = null;
    if (mRunOptions.hasOption ('o'))
      optionValue = mRunOptions.getStringOption ('o');
    else if (mRunOptions.hasOption ("outputDirectory"))
      optionValue = mRunOptions.getStringOption ("outputDirectory");
    else {
      usage ();
      System.exit (0);
      return null;
    }

    String modelId = getModelId ();
    String essayId = getEssayId ();
    String scoreType = getScoreType ();

    String outputFolder = optionValue + "/" + modelId + "/" + essayId + "/" + scoreType;
    return outputFolder;
  }

  protected HashMap<String, AbstractResource> getResources () {
    return mResources;
  }

  /*
   * set up log level from configuration file.
   */
  private void setUpLogLevel () {
    DOMConfigurator.configure ("../conf/log4j.xml");
  }

  /*
   * set up some base argument options.
   * 
   * @return nothing.
   */
  private void setupAllOptions () {
    mRunOptions = new ArgOptions ();

    // Add option for the config file.
    mRunOptions.addOption ('c', "configFile", "a config file", true, "ConfigFile", "Required");

    // Add a unique essay id
    mRunOptions.addOption ('i', "essayId", "a unique id for this essay. this is what will be used to identify the output files.", true, "EssayIdentity", "Required");

    // add a unique model id.
    mRunOptions.addOption ('m', "modelId", "a model id. model id groups a bunch of models generated for different essays.", true, "ModelIdentity", "Required");

    // add a scoretype id. this is required for essays with scores along
    // multiple dimensions.
    mRunOptions.addOption ('t', "scoreType", "a score type", true, "ScoreType", "Required");

    setupAdditionalOptions ();
  }

  private void registerResources () {
    mResources.put (SpellCheckResource.class.getName (), new SpellCheckResource ());
  }
}
