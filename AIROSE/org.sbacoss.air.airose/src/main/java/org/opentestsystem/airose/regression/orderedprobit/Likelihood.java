/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.regression.orderedprobit;

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Hashtable;

/*
 * Paul Van Wamelen's implementation of Ordered Probit.
 */
// / <summary>
// / This class has all the math for computing the likelihood and its
// derivatives for the data and a particular set of
// / (intermediate) parameters.
// / We will use the notation of
// "A statistical model for the analysis of ordinal level dependent variables"
// by
// / Richard D. McKelvey and William Zovoina, The Journal of Mathematical
// Sociology, 4:1, 103-120 (1975).
// / </summary>
public class Likelihood
{
  private int               scalarM;          // number of response categories
  private int               scalarK;          // number of independent
                                               // variables plus 1 (for the
  // constant term)
  private int               scalarn;          // number of observations
  private int[]             vectorY;          // observed categories
  private double[][]        matrixX;          // dependent variable values for
                                               // each response
  private double[]          vectorXBeta;
  private double[]          vectorMu;
  private double[]          vectorBeta;
  private double[]          vectorNk;         // N(j,k) where observation j was
                                               // in category k
  private double[]          vectorNk1;        // N(j,k-1) where observation j
                                               // was in category
  // k
  private double[]          vectorNYk;        // N(j,k)*Y(j,k)
  private double[]          vectorNYk1;       // N(j,k-1)*Y(j,k-1)
  private double[]          vectorPhiDiff;    // Phi(j,k)-Phi(j,k-1) if
                                               // observation j was
  // in category k
  public ArrayList<Integer> Categories = null;

  public List<Integer> getCategories () {
    return Categories;
  }

  protected Likelihood (int[] observedCategories, double[][] data, int numIndependentVariables, int numObservations) {
    scalarn = numObservations;
    scalarK = numIndependentVariables;
    matrixX = new double[scalarn][scalarK + 1];
    vectorXBeta = new double[scalarn];
    vectorNk = new double[scalarn];
    vectorNk1 = new double[scalarn];
    vectorNYk = new double[scalarn];
    vectorNYk1 = new double[scalarn];
    vectorPhiDiff = new double[scalarn];

    for (int i = 0; i < scalarn; i++) {
      matrixX[i][0] = 1.0;
      for (int j = 1; j <= scalarK; j++)
        matrixX[i][j] = data[i][j - 1];
    }

    vectorY = new int[scalarn];
    Hashtable<Integer, Integer> recoder = new Hashtable<Integer, Integer> ();
    for (int i = 0; i < scalarn; i++)
      recoder.put (observedCategories[i], 0);
    int category = 0;
    Categories = new ArrayList<Integer> ();
    // we will first insert all keys into Categories and then sort it in
    // ascending order.
    for (int observedCategory : recoder.keySet ()) {
      Categories.add (observedCategory);
    }
    // sorting
    Collections.sort (Categories);

    for (int k : Categories) {
      category += 1;
      recoder.put (k, category);
    }
    for (int i = 0; i < scalarn; i++)
      vectorY[i] = recoder.get (observedCategories[i]);

    scalarM = recoder.size ();
  }

  protected double[] InitialValues () {
    double[][] XpX = new double[scalarK + 1][scalarK + 1];
    double[][] XpY = new double[scalarK + 1][1];
    for (int j = 0; j < scalarn; j++) {
      for (int u = 0; u < scalarK + 1; u++) {
        for (int v = 0; v < scalarK + 1; v++)
          XpX[u][v] += matrixX[j][u] * matrixX[j][v];
        XpY[u][0] += matrixX[j][u] * (vectorY[j] - 1.5);
      }
    }

    double[][] p1 = LinearEquationSolver.SolveLinear (XpX, XpY);
    double[] initial = new double[scalarK + scalarM - 1];
    for (int i = 0; i <= scalarK; i++)
      initial[i] = p1[i][0];
    for (int j = 2; j < scalarM; j++)
      initial[scalarK + j - 1] = (double) (j - 1);
    return initial;
  }

  // / <summary>
  // / Call this to do a precomputation with a given set of parameters.
  // / Call this before calling Likelihood, D1 and D2.
  // / pars: index 0 is for the constant term
  // / index 1 to scalarK are for each of the independent variables.
  // / index scalarK+1 to scalarK + scalarM - 2 are for mu_2 to mu_(scalarM -
  // 1).
  // / (mu_0 = -infinity, mu_1 = 0, mu_scalarM = infinity)
  // / </summary>
  protected void Initialize (double[] pars) {
    for (int j = 0; j < scalarn; j++) {
      vectorXBeta[j] = 0;
      for (int i = 0; i <= scalarK; i++)
        vectorXBeta[j] += matrixX[j][i] * pars[i];
    }

    double y;
    for (int j = 0; j < scalarn; j++) {
      // Yjk, Phijk, Njk
      if (vectorY[j] == scalarM) {
        vectorPhiDiff[j] = 1.0;
        vectorNk[j] = 0.0;
        vectorNYk[j] = 0.0;
      } else {
        if (vectorY[j] == 1)
          y = 0.0 - vectorXBeta[j];
        else
          // pars[scalarK+1] is for mu_2 and
          y = pars[scalarK + vectorY[j] - 1] - vectorXBeta[j];
        vectorPhiDiff[j] = NormalDistribution.CDF (y);
        vectorNk[j] = NormalDistribution.PDF (y);
        vectorNYk[j] = vectorNk[j] * y;
      }

      // Yj(k-1), Phij(k-1), Nj(k-1)
      if (vectorY[j] == 1) {
        vectorNk1[j] = 0.0;
        vectorNYk1[j] = 0.0;
      } else {
        if (vectorY[j] == 2)
          y = 0.0 - vectorXBeta[j];
        else
          y = pars[scalarK + vectorY[j] - 2] - vectorXBeta[j];
        vectorPhiDiff[j] = vectorPhiDiff[j] - NormalDistribution.CDF (y);
        vectorNk1[j] = NormalDistribution.PDF (y);
        vectorNYk1[j] = vectorNk1[j] * y;
      }
    }
  }

  protected double LogLikelihood () {
    double ll = 0.0;
    for (int j = 0; j < scalarn; j++) {
      ll += Math.log (vectorPhiDiff[j]);
    }
    return ll;
  }

  protected double[][] D1 () {
    double[][] d1 = new double[scalarK + scalarM - 1][1];
    double c;
    for (int j = 0; j < scalarn; j++) {
      c = (vectorNk1[j] - vectorNk[j]) / vectorPhiDiff[j];
      for (int u = 0; u <= scalarK; u++)
        d1[u][0] += c * matrixX[j][u];
      if (vectorY[j] > 1 && vectorY[j] < scalarM)
        d1[scalarK + vectorY[j] - 1][0] += vectorNk[j] / vectorPhiDiff[j];
      if (vectorY[j] > 2)
        d1[scalarK + vectorY[j] - 2][0] += -vectorNk1[j] / vectorPhiDiff[j];
    }
    return d1;
  }

  protected double[][] D2 () {
    double[][] d2 = new double[scalarK + scalarM - 1][scalarK + scalarM - 1];
    double c, c2;
    for (int j = 0; j < scalarn; j++) {
      c = (vectorNk1[j] - vectorNk[j]) / vectorPhiDiff[j];
      c = (vectorNYk1[j] - vectorNYk[j]) / vectorPhiDiff[j] - c * c;
      for (int u = 0; u <= scalarK; u++)
        for (int v = 0; v <= scalarK; v++)
          d2[u][v] += c * matrixX[j][u] * matrixX[j][v];

      if (vectorY[j] > 1 && vectorY[j] < scalarM) {
        c = vectorNYk[j] / vectorPhiDiff[j] - (vectorNk1[j] - vectorNk[j]) * vectorNk[j] / (vectorPhiDiff[j] * vectorPhiDiff[j]);
        for (int u = 0; u <= scalarK; u++) {
          c2 = c * matrixX[j][u];
          d2[u][scalarK + vectorY[j] - 1] += c2;
          d2[scalarK + vectorY[j] - 1][u] += c2;
        }
      }
      if (vectorY[j] > 2) {
        c = -vectorNYk1[j] / vectorPhiDiff[j] + (vectorNk1[j] - vectorNk[j]) * vectorNk1[j] / (vectorPhiDiff[j] * vectorPhiDiff[j]);
        for (int u = 0; u <= scalarK; u++) {
          c2 = c * matrixX[j][u];
          d2[u][scalarK + vectorY[j] - 2] += c2;
          d2[scalarK + vectorY[j] - 2][u] += c2;
        }
      }

      if (vectorY[j] > 1 && vectorY[j] < scalarM)
        d2[scalarK + vectorY[j] - 1][scalarK + vectorY[j] - 1] += -vectorNYk[j] / vectorPhiDiff[j] - vectorNk[j] * vectorNk[j] / (vectorPhiDiff[j] * vectorPhiDiff[j]);
      if (vectorY[j] > 2) {
        c = vectorNk[j] * vectorNk1[j] / (vectorPhiDiff[j] * vectorPhiDiff[j]);
        if (vectorY[j] < scalarM) {
          d2[scalarK + vectorY[j] - 2][scalarK + vectorY[j] - 1] += c;
          d2[scalarK + vectorY[j] - 1][scalarK + vectorY[j] - 2] += c;
        }
        d2[scalarK + vectorY[j] - 2][scalarK + vectorY[j] - 2] += vectorNYk1[j] / vectorPhiDiff[j] - vectorNk1[j] * vectorNk1[j] / (vectorPhiDiff[j] * vectorPhiDiff[j]);
      }
    }
    return d2;
  }
}
