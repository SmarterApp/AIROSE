/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * Paul Van Wamelen's implementation of Ordered Probit.
 */
package org.opentestsystem.airose.regression.orderedprobit;

public class OrderedProbit
{

  private Integer[] categories;
  private double[]  categoryCuts;
  private double    constantCoefficient;
  private double[]  coefficients;

  public Integer[] getCategories () {
    return this.categories;
  }

  public void setCategories (Integer[] categories) {
    this.categories = categories;
  }

  public double[] getCategoryCuts () {
    return this.categoryCuts;
  }

  public void setCategoryCuts (double[] categoryCuts) {
    this.categoryCuts = categoryCuts;
  }

  public double getConstantCoefficient () {
    return this.constantCoefficient;
  }

  public void setConstantCoefficient (double constantCoefficient) {
    this.constantCoefficient = constantCoefficient;
  }

  public double[] getCoefficients () {
    return this.coefficients;
  }

  public void setCoefficients (double[] coefficients) {
    this.coefficients = coefficients;
  }

  protected OrderedProbit () {
  }

  protected OrderedProbit (Integer[] categories, double[] categoryCuts, double constantCoefficient, double[] coefficients) {
    this.categories = categories;
    this.categoryCuts = categoryCuts;
    this.constantCoefficient = constantCoefficient;
    this.coefficients = coefficients;
  }

  public void EstimateOrderedProbit (double[] yData, double[][] xData) throws OrderedProbitException {
    /*
     * we do not have the description of the independent variables. we will just
     * name them "x<i>".
     */
    String[] xDescriptors = new String[xData[0].length];
    for (int counter1 = 0; counter1 < xDescriptors.length; ++counter1) {
      xDescriptors[counter1] = "x" + counter1;
    }

    EstimateOrderedProbit (yData, xDescriptors, xData);
  }

  public void EstimateOrderedProbit (double[] yData, String[] xDescriptors, double[][] xData) throws OrderedProbitException {
    int[] observedCategories = new int[yData.length];

    for (int counter1 = 0; counter1 < yData.length; ++counter1) {
      observedCategories[counter1] = (int) Math.round (yData[counter1]);
    }

    Likelihood likelihood = new Likelihood (observedCategories, xData, xDescriptors.length, yData.length);

    if (likelihood.getCategories ().size () == 1)
      throw new OrderedProbitException ("OrderedProbit model can not be estimated with just one observed category");

    categories = likelihood.getCategories ().toArray (new Integer[likelihood.getCategories ().size ()]);
    categoryCuts = new double[categories.length - 2];

    int maxIterationCount = 100;
    int iterationCount = 0;
    double logLikelihood = Double.NEGATIVE_INFINITY;
    double newLogLikelihood;
    double convergenceDelta = 0.0000001;

    double[] pars = likelihood.InitialValues ();
    likelihood.Initialize (pars);
    while (iterationCount < maxIterationCount) {
      iterationCount += 1;
      double[][] d1 = likelihood.D1 ();
      double[][] d2 = likelihood.D2 ();
      double[][] update = LinearEquationSolver.SolveLinear (d2, d1);
      // Make sure the category cuts will still be of increasing size
      // after the update
      double minf = 1.0;
      if (categories.length > 2) {
        minf = pars[xDescriptors.length + 1] / update[xDescriptors.length + 1][0];
        if (minf < 0.0 || minf > 1.0)
          minf = 1.0;
        for (int j = 1; j < categories.length - 2; j++) {
          double f = (pars[xDescriptors.length + j + 1] - pars[xDescriptors.length + j]) / (update[xDescriptors.length + j + 1][0] - update[xDescriptors.length + j][0]);
          if (f > 0.0 && f < minf)
            minf = f;
        }
        if (minf < 1.0)
          minf = minf / 2.0;
      }
      for (int j = 0; j < update.length; j++)
        pars[j] -= minf * update[j][0];

      likelihood.Initialize (pars);
      newLogLikelihood = likelihood.LogLikelihood ();

      if (Math.abs (newLogLikelihood - logLikelihood) < convergenceDelta)
        break;

      while (newLogLikelihood < logLikelihood) {
        minf = minf / 2.0;
        for (int j = 0; j < update.length; j++)
          pars[j] += minf * update[j][0];
        likelihood.Initialize (pars);
        newLogLikelihood = likelihood.LogLikelihood ();
        if (minf < 0.001)
          throw new OrderedProbitException ("OrderedProbit failed to converge...");
      }
      logLikelihood = newLogLikelihood;
    }
    if (iterationCount == maxIterationCount) {
      throw new OrderedProbitException ("OrderedProbit did not converge...");
    }

    constantCoefficient = pars[0];
    coefficients = new double[xDescriptors.length];
    for (int j = 0; j < xDescriptors.length; j++)
      coefficients[j] = pars[j + 1];
    for (int j = 0; j < categories.length - 2; j++)
      categoryCuts[j] = pars[xDescriptors.length + j + 1];

    System.err.println ("Constant: " + constantCoefficient);
    for (int i = 0; i < xDescriptors.length; i++)
      System.err.println ("coef " + (i + 1) + ": " + coefficients[i]);
    System.err.println ("cut 1: 0.0");
    for (int i = 0; i < categories.length - 2; i++)
      System.err.println ("cut " + (i + 2) + ": " + categoryCuts[i]);
  }

  protected int Predict (double[] independentValues, OrderedProbitDocumentStats docStats) {
    double ystar = constantCoefficient;
    for (int j = 0; j < independentValues.length; j++)
      ystar += independentValues[j] * coefficients[j];

    double maxProb = NormalDistribution.CDF (-ystar);

    if (categories.length == 2) {
      if (maxProb > 0.5)
        return categories[0];
      else
        return categories[1];
    }

    int returnValue = categories[0];

    docStats.addToCategoryProbabilities (maxProb);

    double thisProb = NormalDistribution.CDF (categoryCuts[0] - ystar) - NormalDistribution.CDF (-ystar);
    docStats.addToCategoryProbabilities (thisProb);
    if (thisProb > maxProb) {
      maxProb = thisProb;
      returnValue = categories[1];
    }

    for (int i = 0; i < categoryCuts.length - 1; i++) {
      thisProb = NormalDistribution.CDF (categoryCuts[i + 1] - ystar) - NormalDistribution.CDF (categoryCuts[i] - ystar);
      docStats.addToCategoryProbabilities (thisProb);
      if (thisProb > maxProb) {
        maxProb = thisProb;
        returnValue = categories[i + 2];
      }
    }

    thisProb = 1 - NormalDistribution.CDF (categoryCuts[categoryCuts.length - 1] - ystar);
    docStats.addToCategoryProbabilities (thisProb);
    if (thisProb > maxProb) {
      maxProb = thisProb;
      returnValue = categories[categories.length - 1];
    }

    docStats.setThisCategory (returnValue);
    docStats.setThisCategoryProbability (maxProb);
    docStats.setTotalCategories (categories.length);
    return returnValue;
  }
}
