/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.docprocessors;

import java.util.HashMap;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocProcessors;
import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.abstractdocument.AbstractResource;
import org.opentestsystem.airose.common.abstractdocument.DocProcessorException;

/*
 * The response may have punctuations e.g. ?,! all squished in with other
 * characters. This will insert a white space in between so that
 * tokenization/sentence detection can be more deterministic. Note: We will not
 * try to take care of "." here as that may be part of an abbreviation. For that
 * we have AbbreviationDetectionDocProcessor class.
 */
public class ProperPunctuationDocProcessor extends AbstractDocProcessors
{
  public ProperPunctuationDocProcessor (AbstractDocument doc) {
    super (doc);
  }

  public boolean processDocument (HashMap<String, AbstractResource> resourceMap) throws DocProcessorException {
    AbstractDocument document = getDocument ();
    String response = document.getModifiedResponse ();
    document.setModifiedResponse (modifyWord (response));
    return true;
  }

  static final String REPLACEMENT_PATTERN_STRING = "[+|)(#\\/!?&=;,:-_.]*@";

  /*
   * The regular expression is buggy for the second example identified in the
   * main().
   */
  // static final String REPLACEMENT_PATTERN_STRING =
  // "[+|)|(|#|\\|/|!|?|&|=|;|,|:|\\-|_|.|\\]|\\[]";
  // static final Pattern REPLACEMENT_PATTERN =
  // Pattern.compile(REPLACEMENT_PATTERN_STRING);
  private static String modifyWord (String word) {

    if (word == null)
      return null;

    /*
     * this regular expression code is buggy for the 2nd case identified below.
     * 
     * StringBuffer bfr = new StringBuffer(); Matcher m =
     * REPLACEMENT_PATTERN.matcher(word); while(m.find()) {
     * m.appendReplacement(bfr, " " + m.group(0) + " "); } return
     * bfr.toString();
     */
    for (int counter1 = 0; counter1 < REPLACEMENT_PATTERN_STRING.length (); ++counter1) {
      String charAt = "" + REPLACEMENT_PATTERN_STRING.charAt (counter1);
      word = word.replace (charAt, " " + charAt + " ");
    }
    return word;
  }

  public static void main (String argv[]) {
    /*
     * todo: move this into jUnit test.
     */
    System.err.println (ProperPunctuationDocProcessor.modifyWord ("xyz&klm)ijk!_123--=():,\\/#.x[]y"));
    System.err.println (ProperPunctuationDocProcessor.modifyWord ("xyz"));
    System.err.println (ProperPunctuationDocProcessor.modifyWord ("xyz & klm"));
  }
}
