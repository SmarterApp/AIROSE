/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.docprocessors;

import java.util.HashMap;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocProcessors;
import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.abstractdocument.AbstractResource;
import org.opentestsystem.airose.common.abstractdocument.DocProcessorException;

public class AbbreviationsDetectionDocProcessor extends AbstractDocProcessors
{

  public AbbreviationsDetectionDocProcessor (AbstractDocument doc) {
    super (doc);
  }

  public boolean processDocument (HashMap<String, AbstractResource> resourceMap) throws DocProcessorException {
    AbstractDocument doc = getDocument ();
    String response = doc.getModifiedResponse ();
    /*
     * applyAbbrevsAndSpecialTokens(response);
     */
    doc.setModifiedResponse (response);
    return true;
  }

  /*
   * private String applyAbbrevsAndSpecialTokens(String inputText) { //sometimes
   * a sentence not ending with a "." causes issues with parsing. hence if i
   * dont see a stop //i will just add it here. if (inputText != null) {
   * inputText = inputText.trim(); if (inputText.length() > 0) { //todo: the
   * fact that it was an unterminated sentence should probably be noted down.
   * 
   * //check to see that inputText ends with any of these characters "?!."; if
   * (!(inputText.endsWith("?") || inputText.endsWith("!") ||
   * inputText.endsWith("."))) inputText = inputText + ".";
   * 
   * inputText = reformatForAbbrevs(inputText); inputText =
   * splitTokens(inputText); inputText = reformSpecialTokens(true, inputText); }
   * } return inputText; }
   */
  /*
   * We generate an alternate string which takes care of abbreviations. There
   * should be no penalty for this step.
   */
  /*
   * private String reformatForAbbrevs(String inputText) { init(); StringBuilder
   * alternateStringBuilder = new StringBuilder();
   * List<App.Common.Spelling.Group> possibleAbbreviations =
   * listPossibleAbbreviations(inputText); if (possibleAbbreviations != null) {
   * //reformat. we may have abbreviations. for (int counter1 = 0; counter1 <
   * inputText.Length; ++counter1) { char c = inputText[counter1]; if ('.' == c)
   * { boolean found = false; //was it part of any abbreviations? foreach
   * (App.Common.Spelling.Group abbreviation in possibleAbbreviations) { if
   * (counter1 == abbreviation.Index + abbreviation.Value.Length - 1) { //last
   * dot. lets pad it. alternateStringBuilder.Append(". "); found = true; break;
   * } else if (counter1 > abbreviation.Index && counter1 < (abbreviation.Index
   * + abbreviation.Value.Length)) { //ok...so this '.' is in the middle of an
   * abbreviation. lets not touch it. alternateStringBuilder.Append("."); found
   * = true; break; } } if (!found) { string lastToken =
   * getTheLastToken(alternateStringBuilder); if (!"".Equals(lastToken)) {
   * lastToken = lastToken.ToLower(); if
   * (CommonAbbreviations.ContainsKey(lastToken + ".")) //pad only towards the
   * end. alternateStringBuilder.Append(". "); else //possible sentence breaker
   * period. lets pad. alternateStringBuilder.Append(" . "); } } } // for
   * backwards compatibility, TOKEN_ENDS contains a whitespace as well else if
   * (TOKEN_ENDS.IndexOf(c) >= 0 && ' ' != c) alternateStringBuilder.Append(" "
   * + c + " "); else alternateStringBuilder.Append(c); } } else { //ok we do
   * not think we have abbreviations here. //so lets split along the lines of .
   * ! and ? for (int counter1 = 0; counter1 < text.Length; ++counter1) { char c
   * = text[counter1]; if (TOKEN_ENDS.Contains("" + c)) { if (c == '.') { string
   * lastToken = getTheLastToken(alternateStringBuilder); if
   * (!"".Equals(lastToken)) { lastToken = lastToken.ToLower(); if
   * (CommonAbbreviations.ContainsKey(lastToken + ".")) //so this is a common
   * abbreviation. pad only towards the end.
   * alternateStringBuilder.Append(". "); else //possible sentence breaker
   * period. lets pad. alternateStringBuilder.Append(" . "); } } else // the
   * "((c != ' ') ? " " : \"\")" block is for backwards compatibility,
   * TOKEN_ENDS contains a whitespace as well alternateStringBuilder.Append(((c
   * != ' ') ? " " : "") + c + ((c != ' ') ? " " : "")); } else
   * alternateStringBuilder.Append("" + c); } } return
   * alternateStringBuilder.ToString(); }
   * 
   * final String TOKEN_ENDS = " +%.!?;,"; //whitespace is required. final
   * String SENTENCE_REGEX = "(([A-Za-z0-9]\\.){2,})"; static Regex regex = new
   * Regex(SENTENCE_REGEX); public static List<App.Common.Spelling.Group>
   * listPossibleAbbreviations(String text) { Match m = regex.Match(text); if
   * (m.Success) { List<App.Common.Spelling.Group> finalListOfGroups = new
   * List<App.Common.Spelling.Group>(); { List<App.Common.Spelling.Group>
   * candidateGroups = new List<App.Common.Spelling.Group>(); GroupCollection gc
   * = m.Groups; foreach (Group gp in gc) { App.Common.Spelling.Group
   * gpreplacement = new App.Common.Spelling.Group(gp); string match =
   * gpreplacement.Value; if (match.Length <= 2) continue; int index =
   * gpreplacement.Index; if (gpreplacement.Index > 0) { //lets see if it was
   * extracted from "there.u.s.a" as "e.u.s.a". char c =
   * text[gpreplacement.Index - 1]; if (!TOKEN_ENDS.Contains("" + c)) {
   * //ok...the first two characters are invalied e.g. "e." is invalid. //lets
   * trim. match = match.Substring(2); index = gpreplacement.Index + 2; } }
   * //lets check the tail. //if match ends with a "." then dont bother doing
   * anything else. if (match[match.Length - 1] != '.') { if
   * (gpreplacement.Index + gpreplacement.Value.Length < text.Length - 1) {
   * //lets see if it was extracted from "u.s.a.there  ..." as "u.s.a.t". char c
   * = text[gpreplacement.Index + gpreplacement.Value.Length]; if
   * (!TOKEN_ENDS.Contains("" + c)) { //ok...the first two characters are
   * invalied e.g. "e." is invalid. //lets trim. match = match.Substring(0,
   * match.Length - 2); } } } if (match.Length > 2) candidateGroups.Add(new
   * App.Common.Spelling.Group(match, index)); }
   * 
   * foreach (App.Common.Spelling.Group gp in candidateGroups) {
   * 
   * //lets see if this supersedes existing groups. bool contained = false; for
   * (int counter1 = 0; counter1 < finalListOfGroups.Count; ++counter1) {
   * App.Common.Spelling.Group addedGroup = finalListOfGroups[counter1]; //is
   * any other group part of this? if (addedGroup.Index >= gp.Index &&
   * addedGroup.Index < (gp.Index + gp.Value.Length)) {
   * finalListOfGroups.RemoveAt(counter1); --counter1; continue; } //is this
   * part of any other group? if (gp.Index >= addedGroup.Index && gp.Index <
   * (addedGroup.Index + addedGroup.Value.Length)) { contained = true; break; }
   * } if (!contained) finalListOfGroups.Add(gp);
   * 
   * } }
   * 
   * return finalListOfGroups.Count != 0 ? finalListOfGroups : null; } return
   * null; }
   */
}
