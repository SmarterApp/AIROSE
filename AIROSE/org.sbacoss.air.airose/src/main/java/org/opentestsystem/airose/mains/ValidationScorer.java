/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.mains;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.log4j.Logger;
import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.config.ConfigurationFactory;
import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.common.config.ValidationConfiguration;
import org.opentestsystem.airose.common.config.ConfigurationFactory.ConfigurationType;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.document.DocumentFactory;
import org.opentestsystem.airose.regression.AbstractDocumentStats;
import org.opentestsystem.airose.utilities.LoggerUtil;
import org.opentestsystem.airose.validation.stats.AverageWordCountStats;
import org.opentestsystem.airose.validation.stats.PearsonCorrelationCalculator;
import org.opentestsystem.airose.validation.stats.PercentageExactMatchCalculator;
import org.opentestsystem.airose.validation.stats.StatsProcessor;

public class ValidationScorer extends Scorer
{

  private static final Logger LOGGER           = Logger.getLogger (ValidationScorer.class.getName ());

  /**
   * The counter for recording the current number of documents observed.
   * Subclasses can use this for any reporting.
   */
  private AtomicInteger       mDocumentCounter = new AtomicInteger (0);

  /*
   * Validation stats output file
   */
  StatsProcessor              mStatsProcessor  = null;

  public ValidationScorer (String argv[]) {
    super (argv);
  }

  public static void main (String argv[]) {
    ValidationScorer validation = new ValidationScorer (argv);
    validation.run ();
  }

  protected boolean initialization () throws UninitializedException, SessionException {
    if (!super.initialization ())
      return false;
    // now lets open up the output stream.
    String outputFolder = getOutputFolder ();
    createFolder (outputFolder);

    return true;
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#customRun()
   */
  protected void customRun () throws UninitializedException, IOException {
    String directoryName = getInputFolderName ();
    String outputFolder = getOutputFolder ();
    mStatsProcessor = new StatsProcessor (outputFolder, getScoringModel ());
    mStatsProcessor.addToListOfStatProcessors (new PercentageExactMatchCalculator (outputFolder));
    mStatsProcessor.addToListOfStatProcessors (new PearsonCorrelationCalculator (outputFolder));
    mStatsProcessor.addToListOfStatProcessors (new AverageWordCountStats (outputFolder));

    File directory = new File (directoryName);
    String[] listOfFiles = directory.list ();
    for (String file : listOfFiles) {
      try {
        String fileName = directoryName + "/" + file;
        LoggerUtil.info (LOGGER, "Processing %s", fileName);
        BufferedReader reader = new BufferedReader (new FileReader (fileName));
        processDocument (reader, fileName);

      } catch (IOException exp) {
        exp.printStackTrace ();
        LoggerUtil.severe (LOGGER, "Exception processing files for training. Message: %s", exp.getMessage ());
      }
    }

    mStatsProcessor.process ();
  }

  protected void finish () throws UninitializedException, IOException, SessionException {
    // nothing to do here.
  }

  /*
   * just print usage options.
   */
  protected void usage () {
    System.out.println ("usage: java " + this.getClass ().getName () + " " + mRunOptions.prettyPrint ());
  }

  protected void setupAdditionalOptions () {
    // Add input folder.
    addInputFolderOption ();
    // Add option for output folder. the semantic space file will
    // saved to this folder along with other possible files.
    addOutputFolderOption ();

  }

  /*
   * (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#getConfigurationType()
   * 
   * Returns a constant value of ConfigurationType.TRAINER.
   */
  protected ConfigurationType getConfigurationType () {
    return ConfigurationType.VALIDATION;
  }

  private void processDocument (BufferedReader document, String fileName) throws IOException {
    String line = null;
    while ((line = document.readLine ()) != null) {
      try {
        // Each line consists of a score and a response separated by a
        // comma. First process and tokenize the document.
        AbstractDocument doc = DocumentFactory.getDocument (fileName, line, getEssayId (), -1);

        /*
         * since we are invoking scoreResponse with value of "true" for the
         * param alsoProcessAndTokenize, the doc object will contain the old
         * score.
         */
        AbstractDocumentStats docStats = scoreResponse (doc, true);

        mStatsProcessor.addToDocumentStats (docStats);

        int docCount = mDocumentCounter.addAndGet (1);

        if (docCount % 50 == 0)
          LoggerUtil.info (LOGGER, "Processed " + docCount + " documents.");
      } catch (Exception exp) {
        LoggerUtil.severe (LOGGER, "Exception invoking docProcessors/docTokenizers on \"%s\". Message: %s", line, exp.getMessage ());
      }
    }
    // close the document.
    document.close ();
  }

}
