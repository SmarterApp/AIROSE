/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.regression.ols;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.db.accessors.MatrixAccessor;
import org.opentestsystem.airose.db.accessors.ModelEntryAccessor;
import org.opentestsystem.airose.db.entities.EnumScoringStatus;
import org.opentestsystem.airose.db.entities.MatrixType;
import org.opentestsystem.airose.db.entities.Model;
import org.opentestsystem.airose.db.entities.ModelEntriesType;
import org.opentestsystem.airose.db.entities.ModelEntry;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.linear.Matrices;
import org.opentestsystem.airose.linear.Matrix;
import org.opentestsystem.airose.linear.MatrixTypeEnum;
import org.opentestsystem.airose.regression.AbstractDocumentStats;
import org.opentestsystem.airose.regression.AbstractModel;
import org.opentestsystem.airose.regression.ModelLoadingException;
import org.opentestsystem.airose.utilities.StringUtils;

public class OLSModel extends AbstractModel
{

  /*
   * parts of a OLS regression. see
   * http://commons.apache.org/math/userguide/stat
   * .html#a1.5_Multiple_linear_regression for more documentation.
   */
  double[]   mBeta               = null;
  double[]   mResiduals          = null;
  double[][] mParametersVariance = null;
  double     mRegressandVariance = 0;
  double     mRSquared           = 0;
  double     mSigma              = 0;

  /*
   * Empty constructor. To be used only when loading models from database.
   */
  public OLSModel () {
    super ();
  };

  public OLSModel (double[] beta, double[] residuals, double[][] parametersVariance, double regressandVariance, double rSquared, double sigma, double[] yVector, double[][] xVector) {
    super (yVector, xVector);
    this.mBeta = beta;
    this.mRegressandVariance = regressandVariance;
    this.mRSquared = rSquared;
    this.mSigma = sigma;
    this.mResiduals = residuals;
    this.mParametersVariance = parametersVariance;
  }

  public void saveToDatabaseCustom (ModelEntryAccessor dbModelAccessor, MatrixAccessor dbMatrixAccessor, Model md, String outputFolder) throws SessionException, FileNotFoundException {
    PrintWriter prn = new PrintWriter (outputFolder + "/OLSModel.csv");

    ArrayList<ModelEntry> listOfEntries = new ArrayList<ModelEntry> ();

    // write the header.
    final String CSV_STRING = "{0}, {1}, {2}";
    prn.println (StringUtils.format (CSV_STRING, "Entry", "Index", "Type"));

    for (int counter1 = 0; counter1 < mBeta.length; ++counter1) {
      ModelEntry me = new ModelEntry (md.getId (), mBeta[counter1], counter1, ModelEntriesType.BETAS);
      prn.println (StringUtils.format (CSV_STRING, "" + mBeta[counter1], counter1, ModelEntriesType.BETAS.toString ()));
      listOfEntries.add (me);
    }

    listOfEntries.add (new ModelEntry (md.getId (), mRegressandVariance, 0, ModelEntriesType.REGRESSAND_VARIANCE));
    prn.println (StringUtils.format (CSV_STRING, "" + mRegressandVariance, 0, ModelEntriesType.REGRESSAND_VARIANCE.toString ()));

    listOfEntries.add (new ModelEntry (md.getId (), mRSquared, 0, ModelEntriesType.RSQUARED));
    prn.println (StringUtils.format (CSV_STRING, "" + mRSquared, 0, ModelEntriesType.BETAS.toString ()));

    listOfEntries.add (new ModelEntry (md.getId (), mSigma, 0, ModelEntriesType.SIGMA));
    prn.println (StringUtils.format (CSV_STRING, "" + mSigma, 0, ModelEntriesType.SIGMA.toString ()));

    // save residuals.
    for (int counter1 = 0; counter1 < this.mResiduals.length; ++counter1) {
      ModelEntry me = new ModelEntry (md.getId (), this.mResiduals[counter1], counter1, ModelEntriesType.RESIDUALS);
      prn.println (StringUtils.format (CSV_STRING, "" + this.mResiduals[counter1], counter1, ModelEntriesType.RESIDUALS.toString ()));
      listOfEntries.add (me);
    }

    // save parameters variance.
    Matrix matrix = Matrices.create (this.mParametersVariance.length, this.mParametersVariance[0].length, MatrixTypeEnum.REAL2D);
    for (int counter1 = 0; counter1 < this.mParametersVariance.length; ++counter1) {
      double[] array = this.mParametersVariance[counter1];
      for (int counter2 = 0; counter2 < array.length; ++counter2) {
        prn.println (StringUtils.format (CSV_STRING, "" + this.mParametersVariance[counter1][counter2], counter1 + "-" + counter2, ModelEntriesType.PARAMETERS_VARIANCE.toString ()));
        matrix.set (counter1, counter2, this.mParametersVariance[counter1][counter2]);
      }
    }

    dbMatrixAccessor.saveMatrix (matrix, MatrixType.Matrix_PARAMETERS_VARIANCE, md);

    prn.close ();

    dbModelAccessor.saveModelEntries (listOfEntries.iterator ());
    // other values are not required.

  }

  public void loadFromDatabase (Model md, ModelEntryAccessor dbAccessor, int totalRegressorsUsed) throws SessionException, ModelLoadingException {

    List<ModelEntry> betaEntries = dbAccessor.getModelEntries (md, ModelEntriesType.BETAS);
    if (betaEntries == null)
      throw new ModelLoadingException (String.format ("No betas could be retrieved for modeid %s, essay id %s, score type %s", md.getModelId (), md.getEssayId (), md.getScoreType ()));
    // there is the one constant term and that is why the +1.
    int totalNumberOfBetasExpected = totalRegressorsUsed + 1;
    if (betaEntries.size () != totalNumberOfBetasExpected)
      throw new ModelLoadingException (String.format ("%d Betas retrieved for modeid %s, essay id %s, score type %s does not meet the expected size of %d", betaEntries.size (), md.getModelId (),
          md.getEssayId (), md.getScoreType (), md.getNumberOfDimensions () + 1));

    mBeta = new double[totalNumberOfBetasExpected];
    for (ModelEntry me : betaEntries) {
      mBeta[me.getIndex ()] = me.getEntry ();
    }

  }

  public AbstractDocumentStats scoreResponse (Matrix docColumnMatrix, AbstractDocument ownerDoc) {

    OLSDocumentStats stats = new OLSDocumentStats (ownerDoc);
    if (docColumnMatrix != null) {
      double score = mBeta[0];
      for (int counter1 = 0; counter1 < docColumnMatrix.rows (); ++counter1) {
        double value = mBeta[counter1 + 1] * docColumnMatrix.get (counter1, 0);
        score = score + value;
      }
      stats.setNewScore (score);
      stats.setScoringMessage (EnumScoringStatus.SUCCESS);
    } else {
      stats.setNewScore (0);
      stats.setScoringMessage (EnumScoringStatus.NOT_ENOUGH_DATA);
    }
    return stats;
  }

  @SuppressWarnings ("rawtypes")
  public List createEmptyDocumentStatsLists () {
    return new ArrayList<OLSDocumentStats> ();
  }
}
