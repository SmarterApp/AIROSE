/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.docprocessors;

import java.util.HashMap;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocProcessors;
import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.abstractdocument.AbstractResource;
import org.opentestsystem.airose.common.abstractdocument.DocProcessorException;
import org.opentestsystem.airose.languagetool.LanguageTool;
import org.opentestsystem.airose.languagetool.Mistake;
import org.opentestsystem.airose.languagetool.Mistakes;
import org.opentestsystem.airose.languagetool.RuleMatchTypeEnum;
import org.opentestsystem.airose.resources.SpellCheckResource;

public class LanguageToolDocProcessor extends AbstractDocProcessors
{

  public LanguageToolDocProcessor (AbstractDocument doc) {
    super (doc);
  }

  public boolean processDocument (HashMap<String, AbstractResource> resourceMap) throws DocProcessorException {

    SpellCheckResource resource = (SpellCheckResource) resourceMap.get (SpellCheckResource.class.getName ());

    try {
      AbstractDocument doc = getDocument ();
      String response = doc.getModifiedResponse ();
      LanguageTool languageTool = LanguageTool.getInstanceForDefaultLanguage ();
      Mistakes mistakes = languageTool.check (response);

      // we will now modify the response to fix misspellings.
      int startStringIndex = 0;
      StringBuilder builder = new StringBuilder ("");
      for (int counter1 = 0; counter1 < mistakes.getListOfMistakes ().size (); ++counter1) {
        Mistake mistake = mistakes.getListOfMistakes ().get (counter1);
        if (mistake.getMistakeType () == RuleMatchTypeEnum.SPELLING_MISTAKE) {
          if (startStringIndex != mistake.getStartOfContext ()) {
            // append everything from startStringIndex to the start
            // position of this mistake.
            builder.append (response.substring (startStringIndex, mistake.getStartOfContext ()) + " ");
          }

          // do spell check.
          String replacementString = resource.getTheWordFromListPreviouslySeen (mistake.getAllSuggestedReplacements (), mistake.getMistakeWord ());
          if (replacementString == null) {
            // we have not seen this word before. We will replace it
            // with the first suggestion.
            replacementString = mistake.getMistakeWord ();
          }

          builder.append (replacementString + " ");
          // move pointer.
          startStringIndex = mistake.getEndOFContext () + 1;
        }
      }

      if (startStringIndex < response.length () - 1)
        builder.append (response.substring (startStringIndex));

      // update the resposne that we will be processing further.
      doc.setModifiedResponse (builder.toString ());
      // add a tracker for all the spelling mistakes that were found.
      doc.setListOfMistakes (mistakes);
    } catch (Exception exp) {
      throw new DocProcessorException (exp);
    }
    return true;
  }
}
