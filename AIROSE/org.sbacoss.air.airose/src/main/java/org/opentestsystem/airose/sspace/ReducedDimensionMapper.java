/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.sspace;

import java.util.Hashtable;
import java.util.Iterator;
import org.apache.log4j.Logger;
import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.abstractdocument.AbstractToken;
import org.opentestsystem.airose.db.entities.DocumentQuality;
import org.opentestsystem.airose.docquality.DocumentQualityLoader;
import org.opentestsystem.airose.linear.Matrices;
import org.opentestsystem.airose.linear.Matrix;
import org.opentestsystem.airose.linear.MatrixTypeEnum;
import org.opentestsystem.airose.utilities.LoggerUtil;

public class ReducedDimensionMapper
{
  private static final Logger LOGGER               = Logger.getLogger (ReducedDimensionMapper.class.getName ());
  /*
   * mapping of terms-to-dimensions.
   */
  private TermDimensionMap    mTermDimensionMapper = null;

  /*
   * SVD decomposition matrices.
   */
  private Matrix[]            mUSV                 = null;

  /*
   * This is the matrix that will reduce our document column vector to the lower
   * dimension space.
   */
  private Matrix              mConversionMatrix    = null;

  /*
   * the three tuple value to uniquely identify a model.
   */
  private String              mModelId             = null;
  private String              mEssayId             = null;
  private String              mScoreType           = null;

  /*
   * constructor to use if the SVD matrices and the term-dimension map are
   * available.
   */
  public ReducedDimensionMapper (String modelId, String essayId, String scoreType, Matrix[] usv, TermDimensionMap termMapper) {
    mTermDimensionMapper = termMapper;
    mUSV = usv;
    mModelId = modelId;
    mEssayId = essayId;
    mScoreType = scoreType;
    calculateConversionMatrix ();
  }

  /*
   * creates a column matrix for the list of tokens in the reduced dimension
   * space.
   * 
   * @param tokens Iterator of AbstractTokens where each token has a weight. The
   * tokens should be unique within this iterator.
   * 
   * @return column vector in the reduced dimension space.
   */
  public Matrix getReducedDimensionVector (AbstractDocument doc, DocumentQualityLoader documentQualityAssessor) throws InvalidReducedDimensionSpaceDataException {

    Iterator<AbstractToken> tokens = doc.getListOfTokens ().iterator ();
    if (!tokens.hasNext ())
      // empty document; there is nothing to do.
      return null;

    // we want to set the term dimension map to readonly but it may be
    // required to be non-readonly for other stuff.
    // so we will temporarily set it to readonly.
    boolean isReadOnly = mTermDimensionMapper.isReadOnly ();
    mTermDimensionMapper.setReadOnly (true);

    int rowsInColumnVector = mTermDimensionMapper.getNumberOfDimensions ();

    // Convert the Map count to a SparseArray
    double[] documentColumn = new double[rowsInColumnVector];

    while (tokens.hasNext ()) {
      AbstractToken token = tokens.next ();
      int dimension = mTermDimensionMapper.getDimension (token.getToken ());
      if (dimension >= 0 && dimension < documentColumn.length) {
        documentColumn[dimension] = token.getWeight ();
      } else {
        LoggerUtil.info (LOGGER, "Token %s dimension %d exceeds max dimension %d. ModelId %s, EssayId %s, ScoreType %s", token, dimension, rowsInColumnVector, mModelId, mEssayId, mScoreType);
      }
    }

    /*
     * todo: can i create this matrix in a single step rather than create the
     * documentColumn first and then creating the matrix.
     */
    Matrix d = Matrices.create (rowsInColumnVector, 1, MatrixTypeEnum.REAL2D);
    for (int counter1 = 0; counter1 < rowsInColumnVector; ++counter1) {
      d.set (counter1, 0, documentColumn[counter1]);
    }

    // reset the readonly attribute of the term dimension map.
    mTermDimensionMapper.setReadOnly (isReadOnly);

    // now map it to the new dimension space. see documentation for more details
    // on this step.
    doc.setReducedDimensionMatrix (Matrices.multiply (this.mConversionMatrix, d));

    doc.setRegressionInputDocVector (padWithDocumentQualityAttributes (doc, documentQualityAssessor));
    return doc.getRegressionInputDocVector ();
  }

  /*
   * now lets pad other document quality attributes to this column vector.
   */
  private Matrix padWithDocumentQualityAttributes (AbstractDocument doc, DocumentQualityLoader docQualityAssessor) throws InvalidReducedDimensionSpaceDataException {
    Matrix docColumnVector = doc.getReducedDimensionMatrix ();
    if (docColumnVector == null || docColumnVector.columns () > 1)
      throw new InvalidReducedDimensionSpaceDataException ("Either the docColumnVector paramter is null or it is not a column vector");
    // first lets get the weights for the various document quality attributes.
    Hashtable<DocumentQuality, Double> docQualityWeights = docQualityAssessor.getDocumentQualityWeights (doc);

    if (docQualityWeights.size () > 0) {
      Matrix newDocColumnVector = Matrices.create (docColumnVector.rows () + docQualityWeights.size (), 1, MatrixTypeEnum.REAL2D);
      for (int counter1 = 0; counter1 < docColumnVector.rows (); ++counter1) {
        newDocColumnVector.set (counter1, 0, docColumnVector.get (counter1, 0));
      }

      for (DocumentQuality docQuality : docQualityWeights.keySet ()) {
        newDocColumnVector.set (docQuality.getDimension (), 0, docQualityWeights.get (docQuality));
      }
      return newDocColumnVector;
    } else
      return docColumnVector;
  }

  /*
   * calculate the conversion matrix once.
   */
  private void calculateConversionMatrix () {
    if (mConversionMatrix == null) {
      mConversionMatrix = Matrices.multiply (invertDiagonalMatrix (mUSV[1]), Matrices.transpose (mUSV[0]));
    }
  }

  private Matrix invertDiagonalMatrix (Matrix m) {
    Matrix invertedM = Matrices.createDiagonalMatrix (m.columns ());
    Matrices.copyTo (m, invertedM);
    for (int counter = 0; counter < invertedM.rows (); ++counter) {
      double value = invertedM.get (counter, counter);
      invertedM.set (counter, counter, 1 / value);
    }
    return invertedM;
  }
}
