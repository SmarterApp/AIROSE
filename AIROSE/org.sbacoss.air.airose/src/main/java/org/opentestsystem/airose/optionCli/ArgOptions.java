/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.optionCli;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;

public class ArgOptions
{

  protected Options             _options       = new Options ();
  protected Map<String, String> _optionToValue = new HashMap<String, String> ();

  public ArgOptions (Options _options, Map<String, String> optionToValue) {
    this._optionToValue = optionToValue;
    this._options = _options;
  }

  public ArgOptions () {

    this._options = new Options ();
  }

  public boolean hasOption (char optionName) {
    return _options.hasOption (Character.toString (optionName));
  }

  public boolean hasOption (String optionName) {
    return _options.hasOption (optionName);
  }

  public String getStringOption (char optionName) {

    return _optionToValue.get (optionToString (_options.getOption (Character.toString (optionName))));

  }

  public String getStringOption (String optionName) {

    return _optionToValue.get (optionToString (_options.getOption (optionName)));
  }

  public void addOption (char shortName, String longName, String description, boolean hasValue, String valueName, String optionGroupName) {

    _options.addOption (Character.toString (shortName), longName, hasValue, description);
  }

  private String optionToString (Option o) {
    return "-" + o.getOpt () + ", --" + o.getLongOpt ();
  }

  public void parseOptions (String[] commandLine) {

    for (int i = 0; i < commandLine.length; ++i) {
      String s = commandLine[i];

      if (s.startsWith ("--")) {
        // see if the option is combined with a value
        int index = s.indexOf ("=");
        if (index > 0) {
          String optionName = s.substring (2, index);
          String value = s.substring (index + 1);
          if (value.length () == 0) {
            throw new Error ("no value specified for " + optionName);
          }
          Option o = _options.getOption (optionName);
          if (o == null) {
            throw new IllegalArgumentException ("unrecognizedOption: " + s);
          }
          if (o.hasArgName ()) {
            throw new Error ("Option " + optionName + " does not " + "take a value");
          }
          this._optionToValue.put (optionToString (o), value);
        }

        // the option was not combined with a value, but may still
        // require one, so load the Option and then decide
        else {
          String optionName = s.substring (2);
          Option o = _options.getOption (optionName);
          if (o == null) {
            throw new IllegalArgumentException ("unrecognizedOption: " + s);
          }
          if (o.hasArgName ()) {
            // because the value combined case was handled above,
            // the value must be in the next command line argument
            // position
            if (i + 1 >= commandLine.length) {
              throw new Error ("no value specified for " + optionName);
            } else {
              String value = commandLine[++i];
              _optionToValue.put (optionToString (o), value);
            }
          }
          // no value was required for this option.
          else {
            _optionToValue.put (optionToString (o), null);
          }
        }
      }

      // Single character options are more complex as they require
      // handling multiple single character options per string as well as
      // having the value specified as a part of the option string with no
      // intervening '=' character.
      else if (s.startsWith ("-")) {

        for (int j = 1; j < s.length (); ++j) {

          char optionName = s.charAt (j);
          Option o = _options.getOption (Character.toString (optionName));
          if (o == null) {
            throw new IllegalArgumentException ("unrecognizedOption: " + s);
          }
          // hasValue()
          if (o.hasArgName ()) {
            // see if there are remaining characters as a part of
            // this string and if so, use them as the value,
            // e.g. -xtrue
            if (j + 1 < s.length ()) {
              String value = s.substring (j + 1);
              _optionToValue.put (optionToString (o), value);
            }

            // otherwise, the next argument in command line is the
            // value for this option
            else {
              // check to ensure that there is at least one more
              // value
              if (i + 1 == commandLine.length) {
                throw new Error ("no value specified for " + o);
              }
              String value = commandLine[++i];
              _optionToValue.put (optionToString (o), value);
            }

            break;
          } else {
            _optionToValue.put (optionToString (o), null);
          }
        }
      }

    }
  }

  public String prettyPrint () {

    return _options.toString ();
  }

}
