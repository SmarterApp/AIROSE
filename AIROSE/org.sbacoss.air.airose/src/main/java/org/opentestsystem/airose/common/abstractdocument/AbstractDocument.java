/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.common.abstractdocument;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;

import opennlp.tools.parser.Parse;

import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.docquality.ConventionsDocumentQualityHolder;
import org.opentestsystem.airose.languagetool.Mistakes;
import org.opentestsystem.airose.linear.Matrix;

public abstract class AbstractDocument
{

  /*
   * a fileName if applicable.
   */
  protected String                           mFileName                 = null;

  /*
   * the unique essay id.
   */
  protected String                           mEssayId                  = null;

  /*
   * the unique doc id
   */
  protected String                           mDocId                    = null;

  /*
   * word count: may not be the same as the count of tokens e.g. "wal mart" may
   * be counted as one word.
   */
  protected int                              mWordCount                = 0;

  /*
   * list of concepts - they may be muti-word.
   */
  protected List<AbstractToken>              mListOfConcepts           = new ArrayList<AbstractToken> ();

  /*
   * the actual response.
   */
  protected String                           mOriginalResponse         = null;

  /*
   * a score: does not matter if this is human assigned or machine assigned.
   */
  protected double                           mScore                    = -1;

  /*
   * the sentences in the response.
   */
  protected String[]                         mSentences                = null;

  /*
   * the openNLP parse trees.
   */
  protected Parse[]                          mParse                    = null;

  /*
   * the results of language tool processing.
   */
  protected Mistakes                         mListOfMistakes           = null;

  /*
   * the original response may have to be processed further before it is used.
   */
  protected String                           mModifiedResponse         = null;

  /*
   * store other columns that are in the record.
   */
  protected Hashtable<String, String>        mColumns                  = new Hashtable<String, String> ();

  /*
   * reduced dimension column vector
   */
  protected Matrix                           mReducedDimensionMatrix   = null;

  /*
   * this is the final document vector and includes the mReducedDimentuionMatris
   * as the first set of columns and then padded with all quality attributes.
   */
  protected Matrix                           mRegressionInputDocVector = null;

  /*
   * columns for which we need to print aggregate statistics. score is one of
   * those but we handle scores differently.
   */
  protected HashSet<String>                  mAggregateColumns         = new HashSet<String> ();

  // syntax assessments
  protected ConventionsDocumentQualityHolder mConventionsAssessments   = null;

  public ConventionsDocumentQualityHolder getConventionsAssessments () {
    return mConventionsAssessments;
  }

  public void setConventionsAssessments (ConventionsDocumentQualityHolder values) {
    this.mConventionsAssessments = values;
  }

  public Matrix getRegressionInputDocVector () {
    return mRegressionInputDocVector;
  }

  public void setRegressionInputDocVector (Matrix m) {
    this.mRegressionInputDocVector = m;
  }

  public String getFileName () {
    return this.mFileName;
  }

  public void setFileName (String fileName) {
    this.mFileName = fileName;
  }

  public String getEssaySetId () {
    return mEssayId;
  }

  public void setEssaySetId (String id) {
    this.mEssayId = id;
  }

  public String getDocId () {
    return this.mDocId;
  }

  public void setDocId (String docId) {
    this.mDocId = docId;
  }

  public String getModifiedResponse () {
    return mModifiedResponse;
  }

  public void setModifiedResponse (String response) {
    mModifiedResponse = response;
  }

  public double getSentenceCount () {
    String[] sentences = getSentences ();
    if (sentences != null)
      return sentences.length;
    return 0;
  }

  public String[] getSentences () {
    return mSentences;
  }

  public void setSentences (String[] sentences) {
    mSentences = sentences;
  }

  public Parse[] getParse () {
    return this.mParse;
  }

  public void setParse (Parse[] parses) {
    mParse = parses;
  }

  public Iterator<String> getAggregateKeysetIterator () {
    return mAggregateColumns.iterator ();
  }

  public List<AbstractToken> getListOfTokens () {
    return mListOfConcepts;
  }

  public Iterator<AbstractToken> getListOfConceptsIterator () {
    return mListOfConcepts.iterator ();
  }

  public double getScore () {
    return this.mScore;
  }

  public void setScore (double score) {
    this.mScore = score;
  }

  public String getOriginalResponse () {
    return mOriginalResponse;
  }

  public void setOriginalResponse (String response) {
    this.mOriginalResponse = response;
  }

  public int getWordCount () {
    return this.mWordCount;
  }

  public void setWordCount (int count) {
    this.mWordCount = count;
  }

  public void addColumnData (String key, String value) {
    this.mColumns.put (key, value);
  }

  public void addColumnData (String key, String value, boolean isAggregateValue) {
    addColumnData (key, value);
    if (isAggregateValue)
      mAggregateColumns.add (key);
  }

  public Iterator<String> getColumnIterator () {
    return this.mColumns.keySet ().iterator ();
  }

  public String getColumnValue (String key) {
    String value = this.mColumns.get (key);
    if (value == null)
      value = "N/A";
    return value;
  }

  public void setListOfMistakes (Mistakes mistakes) {
    this.mListOfMistakes = mistakes;
  }

  public Mistakes getMistakes () {
    return this.mListOfMistakes;
  }

  public Matrix getReducedDimensionMatrix () {
    return this.mReducedDimensionMatrix;
  }

  public void setReducedDimensionMatrix (Matrix matrix) {
    this.mReducedDimensionMatrix = matrix;
  }

  /*
   * invoke document preprocessors.
   */

  public void invokeDocumentPreprocessors (HashMap<String, AbstractResource> resourceMap) throws DocProcessorException {
    List<AbstractDocProcessors> listOfDocProcessors = getListOfDocumentPreprocessors ();
    if (listOfDocProcessors != null) {
      for (AbstractDocProcessors docProcessor : listOfDocProcessors) {
        boolean continueProcessing = docProcessor.processDocument (resourceMap);
        if (!continueProcessing)
          break;
      }
    }
  }

  /*
   * invoke document processors. these basically will mash up the response in
   * various ways.
   */
  public void invokeDocumentProcessors (HashMap<String, AbstractResource> resourceMap) throws DocProcessorException {
    List<AbstractDocProcessors> listOfDocProcessors = getListOfDocumentProcessors ();
    for (AbstractDocProcessors docProcessor : listOfDocProcessors) {
      boolean continueProcessing = docProcessor.processDocument (resourceMap);
      if (!continueProcessing)
        break;
    }
  }

  /*
   * invoke document tokenizers. these tokenize the document into entities and
   * attach weight to each.
   */
  public void invokeDocumentTokenizers () throws DocTokenizationException {
    List<AbstractDocTokenizers> listOfDocumentTokenizers = getListOfDocumentTokenizers ();
    for (AbstractDocTokenizers docTokenizer : listOfDocumentTokenizers) {
      boolean continueProcessing = docTokenizer.tokenizeDocument ();
      if (!continueProcessing)
        break;
    }
  }

  /*
   * Assigns term weights based on frequency.
   */
  public void assignTermWeights () throws TermWeightAssignmentException, UninitializedException {
    AbstractTermWeightsProcessor processor = getTermWeightsProcessor ();
    processor.assignTermWeights ();
  }

  protected AbstractDocument (String fileName, String response, double score, String essayId) {
    setFileName (fileName);
    setOriginalResponse (response);
    setModifiedResponse (response);
    setEssaySetId (essayId);
    setScore (score);
  }

  protected abstract List<AbstractDocProcessors> getListOfDocumentPreprocessors ();

  protected abstract List<AbstractDocProcessors> getListOfDocumentProcessors ();

  protected abstract List<AbstractDocTokenizers> getListOfDocumentTokenizers ();

  protected abstract AbstractTermWeightsProcessor getTermWeightsProcessor () throws UninitializedException;
}
