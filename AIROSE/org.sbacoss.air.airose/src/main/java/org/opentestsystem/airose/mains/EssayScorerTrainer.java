/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.mains;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;

import org.apache.log4j.Logger;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.config.ConfigurationFactory;
import org.opentestsystem.airose.common.config.TrainerConfiguration;
import org.opentestsystem.airose.common.config.UninitializedException;
import org.opentestsystem.airose.common.config.ConfigurationFactory.ConfigurationType;
import org.opentestsystem.airose.db.accessors.ModelAccessor;
import org.opentestsystem.airose.db.accessors.ReadOnlyModeException;
import org.opentestsystem.airose.db.accessors.UniqueResultException;
import org.opentestsystem.airose.db.entities.EnumRegressionModel;
import org.opentestsystem.airose.db.entities.Model;
import org.opentestsystem.airose.db.entities.PreviouslySeenWords;
import org.opentestsystem.airose.db.entities.xml.XmlItemModels;
import org.opentestsystem.airose.db.session.DBSession;
import org.opentestsystem.airose.db.session.DBSessionFactory;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.docquality.DocumentQualityLoader;
import org.opentestsystem.airose.document.DocumentFactory;
import org.opentestsystem.airose.linear.Matrix;
import org.opentestsystem.airose.persisters.IModelPersister;
import org.opentestsystem.airose.persisters.ModelHolder;
import org.opentestsystem.airose.regression.AbstractModel;
import org.opentestsystem.airose.regression.EmptyModel;
import org.opentestsystem.airose.regression.EmptyModelDocumentStats;
import org.opentestsystem.airose.regression.RegressionModeller;
import org.opentestsystem.airose.regression.RegressionModellingException;
import org.opentestsystem.airose.resources.ContextBeans;
import org.opentestsystem.airose.resources.SpellCheckResource;
import org.opentestsystem.airose.sspace.LSANotInitializedException;
import org.opentestsystem.airose.sspace.ReducedDimensionMapper;
import org.opentestsystem.airose.sspace.TermDimensionMap;
import org.opentestsystem.airose.sspace.TrainEssayScorerLSA;
import org.opentestsystem.airose.utilities.LoggerUtil;
import org.opentestsystem.airose.validation.stats.AverageWordCountStats;
import org.opentestsystem.airose.validation.stats.StatsProcessor;

import edu.ucla.sspace.common.SemanticSpace;
import edu.ucla.sspace.common.SemanticSpaceIO;
import edu.ucla.sspace.common.SemanticSpaceIO.SSpaceFormat;

public class EssayScorerTrainer extends AbstractMain
{

  private static final Logger   LOGGER              = Logger.getLogger (EssayScorerTrainer.class.getName ());
  /*
   * the SemanticSpace for this training. currently we only support LSA.
   */
  private TrainEssayScorerLSA   mLSA                = null;
  private TermDimensionMap      mDimensionMapper    = null;
  /*
   * keep track of various document quality attributes.
   */
  private DocumentQualityLoader mDocQualityAssessor = null;

  public EssayScorerTrainer (String argv[]) {
    super (argv);
  }

  public static void main (String argv[]) {
    EssayScorerTrainer trainer = new EssayScorerTrainer (argv);
    trainer.run ();
  }

  /*
   * Since we are going to build a model, there is no need to load anything from
   * the database. (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#initialization()
   */
  protected boolean initialization () throws UninitializedException, SessionException {
    return true;
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#customRun()
   */
  protected void customRun () throws UninitializedException, IOException, LSANotInitializedException {

    TrainerConfiguration runConfig = (TrainerConfiguration) ConfigurationFactory.getConfiguration ();

    String modelId = getModelId ();
    String essayId = getEssayId ();
    String scoreType = getScoreType ();

    try {
      DBSession session = DBSessionFactory.getInstance ().getSession (this.hashCode ());
      ModelAccessor modelAccessor = new ModelAccessor (session);

      Model md = modelAccessor.getModel (modelId, essayId, scoreType);
      session.closeSession (this.hashCode ());

      if (md != null)
        throw new UninitializedException (String.format ("A model for  Model Id %s, Essay Id %s and Score Type %s already exists. Atleast one  of the three values have to be unique. Aborting!",
            modelId, essayId, scoreType));
    } catch (SessionException sqlExp) {
      sqlExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception creating session. Message: %s. Exit.", sqlExp.getMessage ());
      return;
    } catch (UniqueResultException uniqueResultExp) {
      uniqueResultExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, uniqueResultExp.getMessage ());
      return;
    }

    EnumRegressionModel regressionModel = runConfig.getRegressionModel ();
    String directoryName = getInputFolderName ();

    String outputFolder = getOutputFolder ();
    createFolder (outputFolder);
    // create a stat processor so that we can extract aggregate values e.g. word
    // count.
    // we do not have a model yet so we will have to use EmptyModel as a
    // placeholder for our model
    StatsProcessor statProcessor = new StatsProcessor (outputFolder, new EmptyModel ());
    statProcessor.addToListOfStatProcessors (new AverageWordCountStats (outputFolder));
    // hack!!! step 0: do a first pass and build the resources. we need to
    // redo this loop.
    File directory = new File (directoryName);
    String[] listOfFiles = directory.list ();
    for (String file : listOfFiles) {
      try {
        String fileName = directoryName + "/" + file;
        BufferedReader reader = new BufferedReader (new FileReader (fileName));
        preProcessDocument (fileName, reader, essayId, statProcessor);
      } catch (IOException exp) {
        exp.printStackTrace ();
        LoggerUtil.severe (LOGGER, "Exception processing files for training. Message: %s", exp.getMessage ());
      }
    }
    // we will print out some statistics about the training documents that do
    // not require a model.
    statProcessor.process ();

    // now make the spell check resource readonly.
    SpellCheckResource resource = (SpellCheckResource) getResources ().get (SpellCheckResource.class.getName ());
    resource.setReadOnly (true);

    // step 1: set the semantic space.
    mDimensionMapper = new TermDimensionMap ();
    mDocQualityAssessor = DocumentQualityLoader.getInstance ();
    mDocQualityAssessor.setOutputFolder (getOutputFolder ());

    mLSA = new TrainEssayScorerLSA (essayId, modelId, scoreType, mDimensionMapper, getResources (), mDocQualityAssessor);

    // step 2: get the list of files that we need to train on.
    directory = new File (directoryName);
    listOfFiles = directory.list ();
    for (String file : listOfFiles) {
      try {
        String fileName = directoryName + "/" + file;
        BufferedReader reader = new BufferedReader (new FileReader (fileName));
        mLSA.setFileBeingCurrentlyProcessed (fileName);
        mLSA.processDocument (reader);

      } catch (IOException exp) {
        exp.printStackTrace ();
        LoggerUtil.severe (LOGGER, "Exception processing files for training. Message: %s", exp.getMessage ());
      }
    }

    // step 3. Process space
    mLSA.processSpace ();

    // step 4: Save the semantic space, the matrices and ``the term
    // dimension
    // information.
    // first lets save the semantic space as that is the easiest one.

    File outputFile = new File (outputFolder + "/" + essayId + ".sspace");
    saveSSpace (mLSA, outputFile);

    /*
     * todo: load these from db instead once we have saved them.
     */
    Model md = new Model (modelId, essayId, scoreType, regressionModel, mLSA.getNumberOfDimensionsInReducedSpace ());
    Matrix[] usv = mLSA.getUSV ();
    /*
     * we have to adjust the dimensions of the document quality attributes that
     * we will be using.
     */
    try {
      mDocQualityAssessor.adjustModelAndDimensions (mLSA.getNumberOfDimensionsInReducedSpace (), md);
    } catch (ReadOnlyModeException readOnlyExp) {
      readOnlyExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception initializing document quality attributes. Message: %s. Exit.", readOnlyExp.getMessage ());
      return;
    } catch (LSANotInitializedException lsaExp) {
      lsaExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception initializing document quality attributes. Message: %s. Exit.", lsaExp.getMessage ());
      return;
    }

    // step 5: create the model.
    // during this step we will set the dimension mapper to readOnly. we
    // will also
    // need to set it to readonly throughout scoring/validation.
    mDimensionMapper.setReadOnly (true);
    // for tracking purposes during training.
    // todo: move to log4j.
    mDocQualityAssessor.initIndividualProcessorTracking ();

    ReducedDimensionMapper dimensionReMapper = new ReducedDimensionMapper (modelId, essayId, scoreType, usv, mDimensionMapper);
    RegressionModeller modeller = new RegressionModeller (modelId, essayId, scoreType, dimensionReMapper, mDocQualityAssessor, getResources (), getOutputFolder ());
    AbstractModel outputModel = null;
    try {
      outputModel = modeller.runRegressionModelling (directoryName);
    } catch (RegressionModellingException modellingExp) {
      modellingExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception generating model. Message: %s.", modellingExp.getMessage ());
      return;
    }

    try {
      saveModelData (md, mDimensionMapper, usv, mDocQualityAssessor, resource, outputModel);
    } catch (ReadOnlyModeException readOnlyExp) {
      readOnlyExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception saving data to db. Message: %s. Exit.", readOnlyExp.getMessage ());
      return;
    } catch (SessionException sqlExp) {
      sqlExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception saving data to db. Message: %s. Exit.", sqlExp.getMessage ());
      return;
    }
    // on all other exceptions we need to mark the model as useless in the
    // database.
    catch (LSANotInitializedException lsaExp) {
      lsaExp.printStackTrace ();
      LoggerUtil.severe (LOGGER, "Exception saving data to db. Message: %s. Exit.", lsaExp.getMessage ());
      return;
    } finally {
      // for tracking purposes during training.
      // todo: move to log4j.
      mDocQualityAssessor.closeIndividualProcessorTracking ();
    }
    // that's it. run validation etc in separate class.
  }

  protected void finish () throws UninitializedException, IOException, SessionException {
    // nothing to do here.
  }

  /*
   * (non-Javadoc)
   * 
   * @see org.air.essayscorer.mains.AbstractMain#getConfigurationType()
   * 
   * Returns a constant value of ConfigurationType.TRAINER.
   */
  protected ConfigurationType getConfigurationType () {
    return ConfigurationType.TRAINER;
  }

  /*
   * just print usage options.
   */
  protected void usage () {
    System.out.println ("usage: java " + this.getClass ().getName () + " " + mRunOptions.prettyPrint ());
  }

  protected void setupAdditionalOptions () {
    // Add input folder.
    addInputFolderOption ();
    // Add option for output folder. the semantic space file will
    // saved to this folder along with other possible files.
    addOutputFolderOption ();
  }

  /**
   * Serializes the {@link SemanticSpace} object to {@code outputFile}. This
   * uses {@code outputFormat} if set by the commandline. If not, this uses the
   * {@link SSpaceFormat} returned by {@link #getSpaceFormat}.
   */
  protected void saveSSpace (SemanticSpace sspace, File outputFile) throws IOException {
    SSpaceFormat format = SSpaceFormat.BINARY;
    SemanticSpaceIO.save (sspace, outputFile, format);
  }

  private void saveModelData (Model md, TermDimensionMap dimensionMapper, Matrix[] usv, DocumentQualityLoader qualityAttributesLoader, SpellCheckResource resource, AbstractModel outputModel)
      throws ReadOnlyModeException, SessionException, LSANotInitializedException, UninitializedException, FileNotFoundException {

    ModelHolder mh = new ModelHolder ();
    mh.setModel (md);
    mh.setDimensionMapper (dimensionMapper);
    mh.setUsvMatrices (usv);
    mh.setDocumentQualityAttributes (qualityAttributesLoader);
    mh.setPreviouslySeenWordsAccessor (resource);
    mh.setRegressionModel (outputModel);

    IModelPersister persister = ContextBeans.get ("IModelPersister", IModelPersister.class);
    persister.persist (mh, getOutputFolder ());
  }


  private void preProcessDocument (String fileName, BufferedReader document, String essayId, StatsProcessor statProcessor) {
    String line = null;
    try {
      while ((line = document.readLine ()) != null) {
        try {
          // Each line consists of a score and a response separated by
          // a comma. First process and tokenize the document.
          AbstractDocument doc = DocumentFactory.getDocument (fileName, line, essayId, -1);
          // process
          doc.invokeDocumentPreprocessors (getResources ());

          statProcessor.addToDocumentStats (new EmptyModelDocumentStats (doc));
        } catch (Exception exp) {
          LoggerUtil.severe (LOGGER, "Exception invoking docProcessors/docTokenizers on \"%s\". Message: %s", line, exp.getMessage ());
        }
      }

      // close the document.
      document.close ();
    } catch (IOException exp) {
      // do nothing.
    }
  }

}
