/*******************************************************************************
 * Copyright (c) 2013 American Institutes for Research
 * 
 * This file is part of AIROSE.
 * 
 * AIROSE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * AIROSE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with AIROSE.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package org.opentestsystem.airose.docquality;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.opentestsystem.airose.common.abstractdocument.AbstractDocument;
import org.opentestsystem.airose.common.config.ConfigurationFactory;
import org.opentestsystem.airose.db.accessors.DocumentQualityAccessor;
import org.opentestsystem.airose.db.accessors.ReadOnlyModeException;
import org.opentestsystem.airose.db.entities.DocumentQuality;
import org.opentestsystem.airose.db.entities.Model;
import org.opentestsystem.airose.db.session.DBSession;
import org.opentestsystem.airose.db.session.SessionException;
import org.opentestsystem.airose.docquality.processors.AbstractDocumentQualityProcessor;
import org.opentestsystem.airose.docquality.processors.DocumentQualityProcessorFactory;
import org.opentestsystem.airose.docquality.processors.DocumentQualityProcessorNotImplementedException;

/*
 * Class to intialize document quality dimensions from database in case of
 * Scorer or ValidationScorer and to save new ones in case of
 * EssayScorerTrainer.
 */
public class DocumentQualityLoader
{
  private boolean                                                      mReadOnly               = false;
  private Hashtable<String, DocumentQuality>                           mKnownDocumentQualities = new Hashtable<String, DocumentQuality> ();
  private Hashtable<DocumentQuality, AbstractDocumentQualityProcessor> mProcessors             = new Hashtable<DocumentQuality, AbstractDocumentQualityProcessor> ();
  private int                                                          mTotalAttributes        = 0;
  private String                                                       mOutputFolder           = null;

  /*
   * @param readOnly object. the internal state may be modified by only calling
   * loadFromDB only.
   */
  public DocumentQualityLoader () {
    this.mReadOnly = true;
  }

  public void setOutputFolder (String outputFolder) {
    this.mOutputFolder = outputFolder;
  }

  public int getTotalNumberOfQualityAttributes () {
    return mTotalAttributes;
  }

  /*
   * load the quality attributes for this model from the DB.
   */
  public void loadFromDB (DBSession session, Model md) throws SessionException, DocumentQualityProcessorNotImplementedException, ReadOnlyModeException {
    List<DocumentQuality> docQualities = (new DocumentQualityAccessor (session)).getListOfDocumentQualitiesInModel (md);
    for (DocumentQuality docQualityAttribute : docQualities) {
      addToDocumentQualityAttribute (docQualityAttribute);
    }
  }

  /*
	 * 
	 */
  public void saveToDB (DocumentQualityAccessor accessor, Model md) throws ReadOnlyModeException, SessionException {
    if (mReadOnly)
      throw new ReadOnlyModeException ("saveToDB invoked on a read-only object.");
    Iterator<DocumentQuality> docQualities = mProcessors.keySet ().iterator ();
    accessor.saveDocumentQualityList (docQualities, md);
  }

  public void adjustModelAndDimensions (int startDimension, Model md) throws ReadOnlyModeException {
    if (mReadOnly)
      throw new ReadOnlyModeException ("adjustModelAndDimensions invoked on a read-only object.");
    Iterator<DocumentQuality> docQualitiesHandled = mProcessors.keySet ().iterator ();
    int counter = 0;
    while (docQualitiesHandled.hasNext ()) {
      DocumentQuality attribute = docQualitiesHandled.next ();
      /*
       * at this point we are going to readjust the dimensions for the document
       * quality attributes.
       */
      attribute.setModelId (md.getId ());
      attribute.setDimension (startDimension + counter);
      ++counter;
    }
  }

  public Hashtable<DocumentQuality, Double> getDocumentQualityWeights (AbstractDocument doc) {
    Hashtable<DocumentQuality, Double> docQualityWeights = new Hashtable<DocumentQuality, Double> ();
    for (DocumentQuality docQuality : mProcessors.keySet ()) {
      AbstractDocumentQualityProcessor processor = mProcessors.get (docQuality);
      double weight = processor.assignQualityWeight (doc);
      docQualityWeights.put (docQuality, weight);
    }
    return docQualityWeights;
  }

  public boolean addToDocumentQualityAttribute (DocumentQuality attribute) throws DocumentQualityProcessorNotImplementedException {
    String qualityUniqueId = attribute.generateUniqueId ();
    if (mKnownDocumentQualities.containsKey (qualityUniqueId))
      return false;

    // also lets add a processor for it.
    AbstractDocumentQualityProcessor processor = DocumentQualityProcessorFactory.createDocumentQualityProcessor (attribute);
    if (processor != null) {
      mProcessors.put (attribute, processor);
      mKnownDocumentQualities.put (qualityUniqueId, attribute);
      ++mTotalAttributes;
    } else if (attribute.getDimension () > 0)
      // seems like for model building we used a quality processor that is
      // not available anymore.
      // we cannot use the existing model with this code base in that
      // cas.e
      throw new DocumentQualityProcessorNotImplementedException (EnumDocumentQualityAttributes.valueOf (attribute.getTerm ()));
    return true;
  }

  public void initIndividualProcessorTracking () throws FileNotFoundException {
    if (mOutputFolder != null) {
      // todo: we need to switch to log4j

      // for each processor open a PrintWriter
      for (Map.Entry<DocumentQuality, AbstractDocumentQualityProcessor> entry : mProcessors.entrySet ()) {
        AbstractDocumentQualityProcessor processor = entry.getValue ();
        DocumentQuality quality = entry.getKey ();

        PrintWriter prn = new PrintWriter (getOutputFileName (quality.generateUniqueId ()));

        processor.setPrintWriter (prn);
      }
    }
  }

  public void closeIndividualProcessorTracking () {
    // todo: we need to switch to log4j
    if (mOutputFolder != null) {
      // todo: we need to switch to log4j

      // for each processor open a PrintWriter
      for (Map.Entry<DocumentQuality, AbstractDocumentQualityProcessor> entry : mProcessors.entrySet ()) {
        AbstractDocumentQualityProcessor processor = entry.getValue ();
        PrintWriter prn = processor.getPrintWriter ();
        if (prn != null)
          prn.close ();
      }
    }
  }

  public void saveToFolder () throws FileNotFoundException {
    PrintWriter prn = new PrintWriter (mOutputFolder + "/DocumentQualityAttributes.txt");
    for (Map.Entry<String, DocumentQuality> entry : mKnownDocumentQualities.entrySet ()) {
      DocumentQuality quality = entry.getValue ();
      prn.println ("========================================");
      prn.println ("Type: " + quality.getTerm ());
      prn.println ("SubType: " + quality.getSubTerm ());
      prn.println ("Dimension: " + quality.getDimension ());
      prn.println ("Unique Id: " + quality.generateUniqueId ());
    }
    prn.close ();
  }

  /*
   * create a document quality loaded with default settings. the defaults of the
   * various document quality attributes are not set yet.
   */
  public static DocumentQualityLoader getInstance () {
    DocumentQualityLoader loader = new DocumentQualityLoader ();
    loader.mReadOnly = false;
    /*
     * we do not statically add document quality attributes anymore. we add them
     * dynamically based on what all mistakes we have encountered in the
     * training data.
     * 
     * however, there are a few attributes we need to add statically.
     */

    try {
      for (EnumDocumentQualityAttributes attributeEnum : EnumDocumentQualityAttributes.values ()) {
        if (attributeEnum.isAddStatically ()) {
          DocumentQuality qualityAtribute = new DocumentQuality (-1, attributeEnum, -1, attributeEnum.toString ());
          loader.addToDocumentQualityAttribute (qualityAtribute);
        }
      }
    } catch (DocumentQualityProcessorNotImplementedException exp) {
      // should never get thrown here.
    }

    return loader;
  }

  private String getOutputFileName (String qualityAttributeName) {
    // todo: StringUtils has a bug here.
    String configurationType = ConfigurationFactory.getConfigurationType ().toString ();
    return mOutputFolder + "/" + qualityAttributeName + "-" + configurationType + ".txt";

  }
}
